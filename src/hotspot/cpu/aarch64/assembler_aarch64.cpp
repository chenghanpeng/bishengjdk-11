/*
 * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2014, 2020 Red Hat Inc. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

#include <stdio.h>
#include <sys/types.h>

#include "precompiled.hpp"
#include "asm/assembler.hpp"
#include "asm/assembler.inline.hpp"
#include "interpreter/interpreter.hpp"

#ifndef PRODUCT
const uintptr_t Assembler::asm_bp = 0x00007fffee09ac88;
#endif

#include "compiler/disassembler.hpp"
#include "memory/resourceArea.hpp"
#include "runtime/interfaceSupport.inline.hpp"
#include "runtime/sharedRuntime.hpp"
#include "immediate_aarch64.hpp"

extern "C" void entry(CodeBuffer *cb);

#define __ _masm.
#ifdef PRODUCT
#define BLOCK_COMMENT(str) /* nothing */
#else
#define BLOCK_COMMENT(str) block_comment(str)
#endif

#define BIND(label) bind(label); __ BLOCK_COMMENT(#label ":")

static float unpack(unsigned value);

short Assembler::SIMD_Size_in_bytes[] = {
  // T8B, T16B, T4H, T8H, T2S, T4S, T1D, T2D, T1Q
       8,   16,   8,  16,   8,  16,   8,  16,  16
};

#ifdef ASSERT
static void asm_check(const unsigned int *insns, const unsigned int *insns1, size_t len) {
    bool ok = true;
    for (unsigned int i = 0; i < len; i++) {
      if (insns[i] != insns1[i]) {
        ok = false;
        printf("Ours:\n");
        Disassembler::decode((address)&insns1[i], (address)&insns1[i+1]);
        printf("Theirs:\n");
        Disassembler::decode((address)&insns[i], (address)&insns[i+1]);
        printf("\n");
      }
    }
    assert(ok, "Assembler smoke test failed");
  }

void entry(CodeBuffer *cb) {

  // {
  //   for (int i = 0; i < 256; i+=16)
  //     {
  //    printf("\"%20.20g\", ", unpack(i));
  //    printf("\"%20.20g\", ", unpack(i+1));
  //     }
  //   printf("\n");
  // }

  Assembler _masm(cb);
  address entry = __ pc();

  // Smoke test for assembler

// BEGIN  Generated code -- do not edit
// Generated by aarch64-asmtest.py
    Label back, forth;
    __ bind(back);

// ArithOp
    __ add(r23, r1, r13, Assembler::LSR, 45);          //	add	x23, x1, x13, LSR #45
    __ sub(r8, r30, r12, Assembler::ASR, 56);          //	sub	x8, x30, x12, ASR #56
    __ adds(r27, r23, r14, Assembler::LSL, 54);        //	adds	x27, x23, x14, LSL #54
    __ subs(r21, r15, r20, Assembler::LSR, 38);        //	subs	x21, x15, x20, LSR #38
    __ addw(r25, r17, r4, Assembler::LSL, 3);          //	add	w25, w17, w4, LSL #3
    __ subw(r29, r1, r9, Assembler::ASR, 20);          //	sub	w29, w1, w9, ASR #20
    __ addsw(r10, r26, r9, Assembler::ASR, 9);         //	adds	w10, w26, w9, ASR #9
    __ subsw(r21, r30, r7, Assembler::ASR, 3);         //	subs	w21, w30, w7, ASR #3
    __ andr(r9, r8, r11, Assembler::LSR, 4);           //	and	x9, x8, x11, LSR #4
    __ orr(r3, r18, r1, Assembler::ASR, 1);            //	orr	x3, x18, x1, ASR #1
    __ eor(r10, r20, r2, Assembler::LSL, 27);          //	eor	x10, x20, x2, LSL #27
    __ ands(r12, r9, r11, Assembler::ASR, 31);         //	ands	x12, x9, x11, ASR #31
    __ andw(r20, r9, r30, Assembler::ASR, 26);         //	and	w20, w9, w30, ASR #26
    __ orrw(r21, r10, r26, Assembler::ASR, 17);        //	orr	w21, w10, w26, ASR #17
    __ eorw(r0, r8, r7, Assembler::ASR, 7);            //	eor	w0, w8, w7, ASR #7
    __ andsw(r19, r11, r8, Assembler::LSL, 18);        //	ands	w19, w11, w8, LSL #18
    __ bic(r23, r4, r3, Assembler::LSL, 53);           //	bic	x23, x4, x3, LSL #53
    __ orn(r9, r6, r19, Assembler::LSL, 24);           //	orn	x9, x6, x19, LSL #24
    __ eon(r12, r6, r26, Assembler::LSR, 54);          //	eon	x12, x6, x26, LSR #54
    __ bics(r22, r19, r12, Assembler::LSL, 14);        //	bics	x22, x19, x12, LSL #14
    __ bicw(r29, r13, r22, Assembler::LSL, 11);        //	bic	w29, w13, w22, LSL #11
    __ ornw(r17, r30, r20, Assembler::ASR, 5);         //	orn	w17, w30, w20, ASR #5
    __ eonw(r1, r29, r11, Assembler::LSL, 8);          //	eon	w1, w29, w11, LSL #8
    __ bicsw(r4, r20, r6, Assembler::LSR, 29);         //	bics	w4, w20, w6, LSR #29

// AddSubImmOp
    __ addw(r30, r6, 504u);                            //	add	w30, w6, #504
    __ addsw(r19, r8, 943u);                           //	adds	w19, w8, #943
    __ subw(r29, r10, 365u);                           //	sub	w29, w10, #365
    __ subsw(r4, r8, 284u);                            //	subs	w4, w8, #284
    __ add(r3, r14, 958u);                             //	add	x3, x14, #958
    __ adds(r22, r20, 167u);                           //	adds	x22, x20, #167
    __ sub(r27, r15, 725u);                            //	sub	x27, x15, #725
    __ subs(r24, r28, 947u);                           //	subs	x24, x28, #947

// LogicalImmOp
    __ andw(r25, r25, 2139127680ull);                  //	and	w25, w25, #0x7f807f80
    __ orrw(r13, r26, 2097120ull);                     //	orr	w13, w26, #0x1fffe0
    __ eorw(r21, r13, 3758096384ull);                  //	eor	w21, w13, #0xe0000000
    __ andsw(r2, r3, 1073733632ull);                   //	ands	w2, w3, #0x3fffe000
    __ andr(r8, r10, 1125895612137471ull);             //	and	x8, x10, #0x3ffff0003ffff
    __ orr(r27, r16, 18444492273897963519ull);         //	orr	x27, x16, #0xfff80000001fffff
    __ eor(r27, r3, 4611685469745315712ull);           //	eor	x27, x3, #0x3fffff803fffff80
    __ ands(r4, r23, 18446744056529698815ull);         //	ands	x4, x23, #0xfffffffc00003fff

// AbsOp
    __ b(__ pc());                                     //	b	.
    __ b(back);                                        //	b	back
    __ b(forth);                                       //	b	forth
    __ bl(__ pc());                                    //	bl	.
    __ bl(back);                                       //	bl	back
    __ bl(forth);                                      //	bl	forth

// RegAndAbsOp
    __ cbzw(r3, __ pc());                              //	cbz	w3, .
    __ cbzw(r3, back);                                 //	cbz	w3, back
    __ cbzw(r3, forth);                                //	cbz	w3, forth
    __ cbnzw(r2, __ pc());                             //	cbnz	w2, .
    __ cbnzw(r2, back);                                //	cbnz	w2, back
    __ cbnzw(r2, forth);                               //	cbnz	w2, forth
    __ cbz(r25, __ pc());                              //	cbz	x25, .
    __ cbz(r25, back);                                 //	cbz	x25, back
    __ cbz(r25, forth);                                //	cbz	x25, forth
    __ cbnz(r18, __ pc());                             //	cbnz	x18, .
    __ cbnz(r18, back);                                //	cbnz	x18, back
    __ cbnz(r18, forth);                               //	cbnz	x18, forth
    __ adr(r8, __ pc());                               //	adr	x8, .
    __ adr(r8, back);                                  //	adr	x8, back
    __ adr(r8, forth);                                 //	adr	x8, forth
    __ _adrp(r15, __ pc());                            //	adrp	x15, .

// RegImmAbsOp
    __ tbz(r18, 14, __ pc());                          //	tbz	x18, #14, .
    __ tbz(r18, 14, back);                             //	tbz	x18, #14, back
    __ tbz(r18, 14, forth);                            //	tbz	x18, #14, forth
    __ tbnz(r25, 15, __ pc());                         //	tbnz	x25, #15, .
    __ tbnz(r25, 15, back);                            //	tbnz	x25, #15, back
    __ tbnz(r25, 15, forth);                           //	tbnz	x25, #15, forth

// MoveWideImmOp
    __ movnw(r18, 4126, 16);                           //	movn	w18, #4126, lsl 16
    __ movzw(r30, 13712, 0);                           //	movz	w30, #13712, lsl 0
    __ movkw(r21, 13161, 16);                          //	movk	w21, #13161, lsl 16
    __ movn(r18, 28524, 48);                           //	movn	x18, #28524, lsl 48
    __ movz(r13, 30710, 48);                           //	movz	x13, #30710, lsl 48
    __ movk(r3, 31565, 48);                            //	movk	x3, #31565, lsl 48

// BitfieldOp
    __ sbfm(r10, r1, 0, 3);                            //	sbfm	x10, x1, #0, #3
    __ bfmw(r12, r22, 5, 24);                          //	bfm	w12, w22, #5, #24
    __ ubfmw(r17, r3, 11, 8);                          //	ubfm	w17, w3, #11, #8
    __ sbfm(r0, r3, 11, 14);                           //	sbfm	x0, x3, #11, #14
    __ bfm(r28, r6, 7, 15);                            //	bfm	x28, x6, #7, #15
    __ ubfm(r9, r10, 1, 25);                           //	ubfm	x9, x10, #1, #25

// ExtractOp
    __ extrw(r21, r27, r25, 23);                       //	extr	w21, w27, w25, #23
    __ extr(r14, r17, r22, 17);                        //	extr	x14, x17, x22, #17

// CondBranchOp
    __ br(Assembler::EQ, __ pc());                     //	b.EQ	.
    __ br(Assembler::EQ, back);                        //	b.EQ	back
    __ br(Assembler::EQ, forth);                       //	b.EQ	forth
    __ br(Assembler::NE, __ pc());                     //	b.NE	.
    __ br(Assembler::NE, back);                        //	b.NE	back
    __ br(Assembler::NE, forth);                       //	b.NE	forth
    __ br(Assembler::HS, __ pc());                     //	b.HS	.
    __ br(Assembler::HS, back);                        //	b.HS	back
    __ br(Assembler::HS, forth);                       //	b.HS	forth
    __ br(Assembler::CS, __ pc());                     //	b.CS	.
    __ br(Assembler::CS, back);                        //	b.CS	back
    __ br(Assembler::CS, forth);                       //	b.CS	forth
    __ br(Assembler::LO, __ pc());                     //	b.LO	.
    __ br(Assembler::LO, back);                        //	b.LO	back
    __ br(Assembler::LO, forth);                       //	b.LO	forth
    __ br(Assembler::CC, __ pc());                     //	b.CC	.
    __ br(Assembler::CC, back);                        //	b.CC	back
    __ br(Assembler::CC, forth);                       //	b.CC	forth
    __ br(Assembler::MI, __ pc());                     //	b.MI	.
    __ br(Assembler::MI, back);                        //	b.MI	back
    __ br(Assembler::MI, forth);                       //	b.MI	forth
    __ br(Assembler::PL, __ pc());                     //	b.PL	.
    __ br(Assembler::PL, back);                        //	b.PL	back
    __ br(Assembler::PL, forth);                       //	b.PL	forth
    __ br(Assembler::VS, __ pc());                     //	b.VS	.
    __ br(Assembler::VS, back);                        //	b.VS	back
    __ br(Assembler::VS, forth);                       //	b.VS	forth
    __ br(Assembler::VC, __ pc());                     //	b.VC	.
    __ br(Assembler::VC, back);                        //	b.VC	back
    __ br(Assembler::VC, forth);                       //	b.VC	forth
    __ br(Assembler::HI, __ pc());                     //	b.HI	.
    __ br(Assembler::HI, back);                        //	b.HI	back
    __ br(Assembler::HI, forth);                       //	b.HI	forth
    __ br(Assembler::LS, __ pc());                     //	b.LS	.
    __ br(Assembler::LS, back);                        //	b.LS	back
    __ br(Assembler::LS, forth);                       //	b.LS	forth
    __ br(Assembler::GE, __ pc());                     //	b.GE	.
    __ br(Assembler::GE, back);                        //	b.GE	back
    __ br(Assembler::GE, forth);                       //	b.GE	forth
    __ br(Assembler::LT, __ pc());                     //	b.LT	.
    __ br(Assembler::LT, back);                        //	b.LT	back
    __ br(Assembler::LT, forth);                       //	b.LT	forth
    __ br(Assembler::GT, __ pc());                     //	b.GT	.
    __ br(Assembler::GT, back);                        //	b.GT	back
    __ br(Assembler::GT, forth);                       //	b.GT	forth
    __ br(Assembler::LE, __ pc());                     //	b.LE	.
    __ br(Assembler::LE, back);                        //	b.LE	back
    __ br(Assembler::LE, forth);                       //	b.LE	forth
    __ br(Assembler::AL, __ pc());                     //	b.AL	.
    __ br(Assembler::AL, back);                        //	b.AL	back
    __ br(Assembler::AL, forth);                       //	b.AL	forth
    __ br(Assembler::NV, __ pc());                     //	b.NV	.
    __ br(Assembler::NV, back);                        //	b.NV	back
    __ br(Assembler::NV, forth);                       //	b.NV	forth

// ImmOp
    __ svc(31973);                                     //	svc	#31973
    __ hvc(1113);                                      //	hvc	#1113
    __ smc(24334);                                     //	smc	#24334
    __ brk(7815);                                      //	brk	#7815
    __ hlt(28529);                                     //	hlt	#28529

// Op
    __ nop();                                          //	nop	
    __ eret();                                         //	eret	
    __ drps();                                         //	drps	
    __ isb();                                          //	isb	

// SystemOp
    __ dsb(Assembler::NSHLD);                          //	dsb	NSHLD
    __ dmb(Assembler::NSH);                            //	dmb	NSH

// OneRegOp
    __ br(r28);                                        //	br	x28
    __ blr(r17);                                       //	blr	x17

// LoadStoreExclusiveOp
    __ stxr(r18, r7, r26);                             //	stxr	w18, x7, [x26]
    __ stlxr(r25, r12, r6);                            //	stlxr	w25, x12, [x6]
    __ ldxr(r0, r16);                                  //	ldxr	x0, [x16]
    __ ldaxr(r6, r3);                                  //	ldaxr	x6, [x3]
    __ stlr(r14, r1);                                  //	stlr	x14, [x1]
    __ ldar(r29, r24);                                 //	ldar	x29, [x24]

// LoadStoreExclusiveOp
    __ stxrw(r28, r15, r23);                           //	stxr	w28, w15, [x23]
    __ stlxrw(r9, r7, r3);                             //	stlxr	w9, w7, [x3]
    __ ldxrw(r1, r20);                                 //	ldxr	w1, [x20]
    __ ldaxrw(r20, r15);                               //	ldaxr	w20, [x15]
    __ stlrw(r21, r9);                                 //	stlr	w21, [x9]
    __ ldarw(r5, r17);                                 //	ldar	w5, [x17]

// LoadStoreExclusiveOp
    __ stxrh(r13, r20, r30);                           //	stxrh	w13, w20, [x30]
    __ stlxrh(r10, r12, r18);                          //	stlxrh	w10, w12, [x18]
    __ ldxrh(r4, r19);                                 //	ldxrh	w4, [x19]
    __ ldaxrh(r22, r10);                               //	ldaxrh	w22, [x10]
    __ stlrh(r30, r15);                                //	stlrh	w30, [x15]
    __ ldarh(r4, r24);                                 //	ldarh	w4, [x24]

// LoadStoreExclusiveOp
    __ stxrb(r10, r20, r12);                           //	stxrb	w10, w20, [x12]
    __ stlxrb(r20, r29, r11);                          //	stlxrb	w20, w29, [x11]
    __ ldxrb(r21, r5);                                 //	ldxrb	w21, [x5]
    __ ldaxrb(r4, r9);                                 //	ldaxrb	w4, [x9]
    __ stlrb(r30, r28);                                //	stlrb	w30, [x28]
    __ ldarb(r19, r24);                                //	ldarb	w19, [x24]

// LoadStoreExclusiveOp
    __ ldxp(r11, r16, r18);                            //	ldxp	x11, x16, [x18]
    __ ldaxp(r8, r7, r15);                             //	ldaxp	x8, x7, [x15]
    __ stxp(r28, r20, r16, r10);                       //	stxp	w28, x20, x16, [x10]
    __ stlxp(r7, r9, r21, r3);                         //	stlxp	w7, x9, x21, [x3]

// LoadStoreExclusiveOp
    __ ldxpw(r25, r6, r19);                            //	ldxp	w25, w6, [x19]
    __ ldaxpw(r30, r9, r2);                            //	ldaxp	w30, w9, [x2]
    __ stxpw(r16, r0, r20, r12);                       //	stxp	w16, w0, w20, [x12]
    __ stlxpw(r5, r2, r7, r28);                        //	stlxp	w5, w2, w7, [x28]

// base_plus_unscaled_offset 
// LoadStoreOp
    __ str(r16, Address(r19, -75));                    //	str	x16, [x19, -75]
    __ strw(r1, Address(r28, 30));                     //	str	w1, [x28, 30]
    __ strb(r28, Address(r13, -26));                   //	strb	w28, [x13, -26]
    __ strh(r8, Address(r6, -51));                     //	strh	w8, [x6, -51]
    __ ldr(r0, Address(r28, -227));                    //	ldr	x0, [x28, -227]
    __ ldrw(r28, Address(r10, -26));                   //	ldr	w28, [x10, -26]
    __ ldrb(r4, Address(r11, 12));                     //	ldrb	w4, [x11, 12]
    __ ldrh(r1, Address(r17, 5));                      //	ldrh	w1, [x17, 5]
    __ ldrsb(r11, Address(r9, 12));                    //	ldrsb	x11, [x9, 12]
    __ ldrsh(r8, Address(r8, -17));                    //	ldrsh	x8, [x8, -17]
    __ ldrshw(r20, Address(r13, -35));                 //	ldrsh	w20, [x13, -35]
    __ ldrsw(r23, Address(r9, 49));                    //	ldrsw	x23, [x9, 49]
    __ ldrd(v9, Address(r4, 29));                      //	ldr	d9, [x4, 29]
    __ ldrs(v11, Address(r19, 40));                    //	ldr	s11, [x19, 40]
    __ strd(v25, Address(r20, -43));                   //	str	d25, [x20, -43]
    __ strs(v25, Address(r1, -80));                    //	str	s25, [x1, -80]

// pre 
// LoadStoreOp
    __ str(r20, Address(__ pre(r0, 25)));              //	str	x20, [x0, 25]!
    __ strw(r12, Address(__ pre(r12, -49)));           //	str	w12, [x12, -49]!
    __ strb(r28, Address(__ pre(r19, -10)));           //	strb	w28, [x19, -10]!
    __ strh(r13, Address(__ pre(r28, -63)));           //	strh	w13, [x28, -63]!
    __ ldr(r11, Address(__ pre(r23, -46)));            //	ldr	x11, [x23, -46]!
    __ ldrw(r27, Address(__ pre(r24, 17)));            //	ldr	w27, [x24, 17]!
    __ ldrb(r14, Address(__ pre(r26, -12)));           //	ldrb	w14, [x26, -12]!
    __ ldrh(r24, Address(__ pre(r22, -45)));           //	ldrh	w24, [x22, -45]!
    __ ldrsb(r25, Address(__ pre(r9, -11)));           //	ldrsb	x25, [x9, -11]!
    __ ldrsh(r5, Address(__ pre(r6, 29)));             //	ldrsh	x5, [x6, 29]!
    __ ldrshw(r7, Address(__ pre(r23, -1)));           //	ldrsh	w7, [x23, -1]!
    __ ldrsw(r26, Address(__ pre(r13, -61)));          //	ldrsw	x26, [x13, -61]!
    __ ldrd(v24, Address(__ pre(r24, -245)));          //	ldr	d24, [x24, -245]!
    __ ldrs(v20, Address(__ pre(r25, -55)));           //	ldr	s20, [x25, -55]!
    __ strd(v9, Address(__ pre(r2, -203)));            //	str	d9, [x2, -203]!
    __ strs(v14, Address(__ pre(r1, -59)));            //	str	s14, [x1, -59]!

// post 
// LoadStoreOp
    __ str(r19, Address(__ post(r1, 109)));            //	str	x19, [x1], 109
    __ strw(r4, Address(__ post(r5, -54)));            //	str	w4, [x5], -54
    __ strb(r29, Address(__ post(r3, 9)));             //	strb	w29, [x3], 9
    __ strh(r0, Address(__ post(r1, -50)));            //	strh	w0, [x1], -50
    __ ldr(r2, Address(__ post(r6, -48)));             //	ldr	x2, [x6], -48
    __ ldrw(r15, Address(__ post(r6, -115)));          //	ldr	w15, [x6], -115
    __ ldrb(r4, Address(__ post(r2, -27)));            //	ldrb	w4, [x2], -27
    __ ldrh(r17, Address(__ post(r26, -21)));          //	ldrh	w17, [x26], -21
    __ ldrsb(r21, Address(__ post(r24, -13)));         //	ldrsb	x21, [x24], -13
    __ ldrsh(r22, Address(__ post(r6, -48)));          //	ldrsh	x22, [x6], -48
    __ ldrshw(r11, Address(__ post(r6, -48)));         //	ldrsh	w11, [x6], -48
    __ ldrsw(r14, Address(__ post(r30, -5)));          //	ldrsw	x14, [x30], -5
    __ ldrd(v2, Address(__ post(r15, -105)));          //	ldr	d2, [x15], -105
    __ ldrs(v25, Address(__ post(r19, -91)));          //	ldr	s25, [x19], -91
    __ strd(v13, Address(__ post(r23, -191)));         //	str	d13, [x23], -191
    __ strs(v22, Address(__ post(r21, 0)));            //	str	s22, [x21], 0

// base_plus_reg 
// LoadStoreOp
    __ str(r22, Address(r12, r18, Address::sxtw(0)));  //	str	x22, [x12, w18, sxtw #0]
    __ strw(r30, Address(r27, r12, Address::uxtw(0))); //	str	w30, [x27, w12, uxtw #0]
    __ strb(r7, Address(r4, r22, Address::lsl(0)));    //	strb	w7, [x4, x22, lsl #0]
    __ strh(r19, Address(r23, r29, Address::sxtx(1))); //	strh	w19, [x23, x29, sxtx #1]
    __ ldr(r17, Address(r4, r27, Address::sxtx(3)));   //	ldr	x17, [x4, x27, sxtx #3]
    __ ldrw(r1, Address(r13, r17, Address::sxtw(0)));  //	ldr	w1, [x13, w17, sxtw #0]
    __ ldrb(r16, Address(r27, r29, Address::sxtx(0))); //	ldrb	w16, [x27, x29, sxtx #0]
    __ ldrh(r25, Address(r9, r4, Address::uxtw(1)));   //	ldrh	w25, [x9, w4, uxtw #1]
    __ ldrsb(r4, Address(r12, r22, Address::lsl(0)));  //	ldrsb	x4, [x12, x22, lsl #0]
    __ ldrsh(r25, Address(r1, r5, Address::uxtw(1)));  //	ldrsh	x25, [x1, w5, uxtw #1]
    __ ldrshw(r9, Address(r16, r28, Address::lsl(0))); //	ldrsh	w9, [x16, x28, lsl #0]
    __ ldrsw(r8, Address(r7, r14, Address::sxtx(0)));  //	ldrsw	x8, [x7, x14, sxtx #0]
    __ ldrd(v4, Address(r28, r16, Address::uxtw(3)));  //	ldr	d4, [x28, w16, uxtw #3]
    __ ldrs(v16, Address(r2, r27, Address::sxtw(2)));  //	ldr	s16, [x2, w27, sxtw #2]
    __ strd(v23, Address(r0, r25, Address::lsl(0)));   //	str	d23, [x0, x25, lsl #0]
    __ strs(v6, Address(r16, r7, Address::lsl(2)));    //	str	s6, [x16, x7, lsl #2]

// base_plus_scaled_offset 
// LoadStoreOp
    __ str(r2, Address(r12, 15288));                   //	str	x2, [x12, 15288]
    __ strw(r8, Address(r5, 6928));                    //	str	w8, [x5, 6928]
    __ strb(r1, Address(r17, 2016));                   //	strb	w1, [x17, 2016]
    __ strh(r8, Address(r25, 3258));                   //	strh	w8, [x25, 3258]
    __ ldr(r28, Address(r3, 14656));                   //	ldr	x28, [x3, 14656]
    __ ldrw(r21, Address(r11, 7004));                  //	ldr	w21, [x11, 7004]
    __ ldrb(r15, Address(r5, 1906));                   //	ldrb	w15, [x5, 1906]
    __ ldrh(r0, Address(r19, 3668));                   //	ldrh	w0, [x19, 3668]
    __ ldrsb(r29, Address(r9, 1909));                  //	ldrsb	x29, [x9, 1909]
    __ ldrsh(r23, Address(r28, 3640));                 //	ldrsh	x23, [x28, 3640]
    __ ldrshw(r27, Address(r10, 3672));                //	ldrsh	w27, [x10, 3672]
    __ ldrsw(r21, Address(r27, 7736));                 //	ldrsw	x21, [x27, 7736]
    __ ldrd(v26, Address(r27, 14584));                 //	ldr	d26, [x27, 14584]
    __ ldrs(v2, Address(r4, 7464));                    //	ldr	s2, [x4, 7464]
    __ strd(v1, Address(r21, 16224));                  //	str	d1, [x21, 16224]
    __ strs(v4, Address(r22, 7552));                   //	str	s4, [x22, 7552]

// pcrel 
// LoadStoreOp
    __ ldr(r1, __ pc());                               //	ldr	x1, .
    __ ldrw(r27, __ pc());                             //	ldr	w27, .

// LoadStoreOp
    __ prfm(Address(r4, 45));                          //	prfm	PLDL1KEEP, [x4, 45]

// LoadStoreOp
    __ prfm(__ pc());                                  //	prfm	PLDL1KEEP, .

// LoadStoreOp
    __ prfm(Address(r30, r0, Address::sxtw(0)));       //	prfm	PLDL1KEEP, [x30, w0, sxtw #0]

// LoadStoreOp
    __ prfm(Address(r24, 16208));                      //	prfm	PLDL1KEEP, [x24, 16208]

// AddSubCarryOp
    __ adcw(r0, r29, r24);                             //	adc	w0, w29, w24
    __ adcsw(r22, r28, r18);                           //	adcs	w22, w28, w18
    __ sbcw(r23, r16, r30);                            //	sbc	w23, w16, w30
    __ sbcsw(r7, r29, r14);                            //	sbcs	w7, w29, w14
    __ adc(r22, r12, r14);                             //	adc	x22, x12, x14
    __ adcs(r29, r24, r23);                            //	adcs	x29, x24, x23
    __ sbc(r17, r28, r22);                             //	sbc	x17, x28, x22
    __ sbcs(r24, r20, r19);                            //	sbcs	x24, x20, x19

// AddSubExtendedOp
    __ addw(r27, r22, r6, ext::sxtw, 2);               //	add	w27, w22, w6, sxtw #2
    __ addsw(r13, r11, r24, ext::uxtw, 4);             //	adds	w13, w11, w24, uxtw #4
    __ sub(r16, r8, r4, ext::uxth, 3);                 //	sub	x16, x8, x4, uxth #3
    __ subsw(r21, r18, r20, ext::sxtx, 2);             //	subs	w21, w18, w20, sxtx #2
    __ add(r14, r17, r29, ext::uxtb, 2);               //	add	x14, x17, x29, uxtb #2
    __ adds(r17, r17, r14, ext::sxth, 4);              //	adds	x17, x17, x14, sxth #4
    __ sub(r22, r3, r26, ext::sxtw, 1);                //	sub	x22, x3, x26, sxtw #1
    __ subs(r13, r13, r21, ext::uxth, 4);              //	subs	x13, x13, x21, uxth #4

// ConditionalCompareOp
    __ ccmnw(r17, r26, 15u, Assembler::VC);            //	ccmn	w17, w26, #15, VC
    __ ccmpw(r25, r6, 5u, Assembler::LO);              //	ccmp	w25, w6, #5, LO
    __ ccmn(r1, r30, 1u, Assembler::LS);               //	ccmn	x1, x30, #1, LS
    __ ccmp(r17, r7, 2u, Assembler::GE);               //	ccmp	x17, x7, #2, GE

// ConditionalCompareImmedOp
    __ ccmnw(r17, 25, 6, Assembler::EQ);               //	ccmn	w17, #25, #6, EQ
    __ ccmpw(r2, 5, 5, Assembler::EQ);                 //	ccmp	w2, #5, #5, EQ
    __ ccmn(r19, 17, 10, Assembler::MI);               //	ccmn	x19, #17, #10, MI
    __ ccmp(r14, 8, 3, Assembler::GT);                 //	ccmp	x14, #8, #3, GT

// ConditionalSelectOp
    __ cselw(r9, r8, r14, Assembler::LS);              //	csel	w9, w8, w14, LS
    __ csincw(r27, r11, r5, Assembler::LE);            //	csinc	w27, w11, w5, LE
    __ csinvw(r11, r23, r22, Assembler::LO);           //	csinv	w11, w23, w22, LO
    __ csnegw(r19, r28, r27, Assembler::CS);           //	csneg	w19, w28, w27, CS
    __ csel(r16, r9, r1, Assembler::PL);               //	csel	x16, x9, x1, PL
    __ csinc(r28, r14, r12, Assembler::EQ);            //	csinc	x28, x14, x12, EQ
    __ csinv(r22, r4, r14, Assembler::PL);             //	csinv	x22, x4, x14, PL
    __ csneg(r26, r11, r27, Assembler::HS);            //	csneg	x26, x11, x27, HS

// TwoRegOp
    __ rbitw(r24, r11);                                //	rbit	w24, w11
    __ rev16w(r10, r14);                               //	rev16	w10, w14
    __ revw(r9, r5);                                   //	rev	w9, w5
    __ clzw(r18, r20);                                 //	clz	w18, w20
    __ clsw(r25, r8);                                  //	cls	w25, w8
    __ rbit(r22, r24);                                 //	rbit	x22, x24
    __ rev16(r28, r27);                                //	rev16	x28, x27
    __ rev32(r8, r29);                                 //	rev32	x8, x29
    __ rev(r17, r10);                                  //	rev	x17, x10
    __ clz(r23, r11);                                  //	clz	x23, x11
    __ cls(r26, r14);                                  //	cls	x26, x14

// ThreeRegOp
    __ udivw(r21, r4, r28);                            //	udiv	w21, w4, w28
    __ sdivw(r30, r10, r22);                           //	sdiv	w30, w10, w22
    __ lslvw(r29, r2, r26);                            //	lslv	w29, w2, w26
    __ lsrvw(r28, r22, r10);                           //	lsrv	w28, w22, w10
    __ asrvw(r11, r24, r12);                           //	asrv	w11, w24, w12
    __ rorvw(r21, r30, r16);                           //	rorv	w21, w30, w16
    __ udiv(r1, r0, r13);                              //	udiv	x1, x0, x13
    __ sdiv(r2, r17, r6);                              //	sdiv	x2, x17, x6
    __ lslv(r10, r24, r21);                            //	lslv	x10, x24, x21
    __ lsrv(r5, r9, r6);                               //	lsrv	x5, x9, x6
    __ asrv(r0, r27, r4);                              //	asrv	x0, x27, x4
    __ rorv(r28, r4, r2);                              //	rorv	x28, x4, x2
    __ umulh(r1, r30, r7);                             //	umulh	x1, x30, x7
    __ smulh(r30, r5, r10);                            //	smulh	x30, x5, x10

// FourRegMulOp
    __ maddw(r7, r15, r13, r17);                       //	madd	w7, w15, w13, w17
    __ msubw(r25, r1, r12, r28);                       //	msub	w25, w1, w12, w28
    __ madd(r2, r11, r30, r9);                         //	madd	x2, x11, x30, x9
    __ msub(r5, r23, r3, r22);                         //	msub	x5, x23, x3, x22
    __ smaddl(r25, r10, r9, r4);                       //	smaddl	x25, w10, w9, x4
    __ smsubl(r5, r8, r7, r18);                        //	smsubl	x5, w8, w7, x18
    __ umaddl(r24, r5, r26, r25);                      //	umaddl	x24, w5, w26, x25
    __ umsubl(r14, r1, r26, r28);                      //	umsubl	x14, w1, w26, x28

// ThreeRegFloatOp
    __ fmuls(v24, v22, v8);                            //	fmul	s24, s22, s8
    __ fdivs(v16, v3, v6);                             //	fdiv	s16, s3, s6
    __ fadds(v16, v21, v25);                           //	fadd	s16, s21, s25
    __ fsubs(v0, v26, v27);                            //	fsub	s0, s26, s27
    __ fmuls(v24, v3, v17);                            //	fmul	s24, s3, s17
    __ fmuld(v9, v8, v6);                              //	fmul	d9, d8, d6
    __ fdivd(v22, v19, v30);                           //	fdiv	d22, d19, d30
    __ faddd(v14, v17, v3);                            //	fadd	d14, d17, d3
    __ fsubd(v24, v27, v20);                           //	fsub	d24, d27, d20
    __ fmuld(v12, v1, v22);                            //	fmul	d12, d1, d22

// FourRegFloatOp
    __ fmadds(v16, v8, v11, v29);                      //	fmadd	s16, s8, s11, s29
    __ fmsubs(v22, v19, v18, v1);                      //	fmsub	s22, s19, s18, s1
    __ fnmadds(v15, v24, v24, v9);                     //	fnmadd	s15, s24, s24, s9
    __ fnmadds(v27, v19, v13, v23);                    //	fnmadd	s27, s19, s13, s23
    __ fmaddd(v3, v0, v16, v12);                       //	fmadd	d3, d0, d16, d12
    __ fmsubd(v19, v3, v18, v10);                      //	fmsub	d19, d3, d18, d10
    __ fnmaddd(v1, v2, v11, v20);                      //	fnmadd	d1, d2, d11, d20
    __ fnmaddd(v12, v9, v25, v14);                     //	fnmadd	d12, d9, d25, d14

// TwoRegFloatOp
    __ fmovs(v0, v23);                                 //	fmov	s0, s23
    __ fabss(v23, v6);                                 //	fabs	s23, s6
    __ fnegs(v4, v4);                                  //	fneg	s4, s4
    __ fsqrts(v5, v28);                                //	fsqrt	s5, s28
    __ fcvts(v21, v15);                                //	fcvt	d21, s15
    __ fmovd(v11, v5);                                 //	fmov	d11, d5
    __ fabsd(v18, v4);                                 //	fabs	d18, d4
    __ fnegd(v11, v12);                                //	fneg	d11, d12
    __ fsqrtd(v15, v8);                                //	fsqrt	d15, d8
    __ fcvtd(v8, v2);                                  //	fcvt	s8, d2

// FloatConvertOp
    __ fcvtzsw(r19, v18);                              //	fcvtzs	w19, s18
    __ fcvtzs(r17, v0);                                //	fcvtzs	x17, s0
    __ fcvtzdw(r0, v13);                               //	fcvtzs	w0, d13
    __ fcvtzd(r22, v9);                                //	fcvtzs	x22, d9
    __ scvtfws(v6, r29);                               //	scvtf	s6, w29
    __ scvtfs(v12, r14);                               //	scvtf	s12, x14
    __ scvtfwd(v16, r22);                              //	scvtf	d16, w22
    __ scvtfd(v14, r5);                                //	scvtf	d14, x5
    __ fmovs(r7, v0);                                  //	fmov	w7, s0
    __ fmovd(r28, v6);                                 //	fmov	x28, d6
    __ fmovs(v2, r26);                                 //	fmov	s2, w26
    __ fmovd(v4, r0);                                  //	fmov	d4, x0

// TwoRegFloatOp
    __ fcmps(v1, v11);                                 //	fcmp	s1, s11
    __ fcmpd(v6, v21);                                 //	fcmp	d6, d21
    __ fcmps(v16, 0.0);                                //	fcmp	s16, #0.0
    __ fcmpd(v22, 0.0);                                //	fcmp	d22, #0.0

// LoadStorePairOp
    __ stpw(r5, r0, Address(r2, 96));                  //	stp	w5, w0, [x2, #96]
    __ ldpw(r14, r29, Address(r19, -64));              //	ldp	w14, w29, [x19, #-64]
    __ ldpsw(r15, r3, Address(r3, -160));              //	ldpsw	x15, x3, [x3, #-160]
    __ stp(r7, r13, Address(r27, -224));               //	stp	x7, x13, [x27, #-224]
    __ ldp(r17, r14, Address(r1, 128));                //	ldp	x17, x14, [x1, #128]

// LoadStorePairOp
    __ stpw(r21, r22, Address(__ pre(r4, 128)));       //	stp	w21, w22, [x4, #128]!
    __ ldpw(r17, r13, Address(__ pre(r2, -96)));       //	ldp	w17, w13, [x2, #-96]!
    __ ldpsw(r21, r25, Address(__ pre(r23, -144)));    //	ldpsw	x21, x25, [x23, #-144]!
    __ stp(r4, r16, Address(__ pre(r15, -16)));        //	stp	x4, x16, [x15, #-16]!
    __ ldp(r29, r21, Address(__ pre(r25, -160)));      //	ldp	x29, x21, [x25, #-160]!

// LoadStorePairOp
    __ stpw(r24, r17, Address(__ post(r26, 80)));      //	stp	w24, w17, [x26], #80
    __ ldpw(r3, r30, Address(__ post(r30, -240)));     //	ldp	w3, w30, [x30], #-240
    __ ldpsw(r3, r19, Address(__ post(r30, -32)));     //	ldpsw	x3, x19, [x30], #-32
    __ stp(r25, r1, Address(__ post(r27, -144)));      //	stp	x25, x1, [x27], #-144
    __ ldp(r26, r20, Address(__ post(r28, -64)));      //	ldp	x26, x20, [x28], #-64

// LoadStorePairOp
    __ stnpw(r29, r25, Address(r9, -48));              //	stnp	w29, w25, [x9, #-48]
    __ ldnpw(r25, r14, Address(r19, -128));            //	ldnp	w25, w14, [x19, #-128]
    __ stnp(r25, r22, Address(r3, 32));                //	stnp	x25, x22, [x3, #32]
    __ ldnp(r9, r18, Address(r29, -208));              //	ldnp	x9, x18, [x29, #-208]

// LdStSIMDOp
    __ ld1(v21, __ T8B, Address(r19));                 //	ld1	{v21.8B}, [x19]
    __ ld1(v27, v28, __ T16B, Address(__ post(r20, 32))); //	ld1	{v27.16B, v28.16B}, [x20], 32
    __ ld1(v5, v6, v7, __ T1D, Address(__ post(r22, r6))); //	ld1	{v5.1D, v6.1D, v7.1D}, [x22], x6
    __ ld1(v22, v23, v24, v25, __ T8H, Address(__ post(r12, 64))); //	ld1	{v22.8H, v23.8H, v24.8H, v25.8H}, [x12], 64
    __ ld1r(v17, __ T8B, Address(r9));                 //	ld1r	{v17.8B}, [x9]
    __ ld1r(v5, __ T4S, Address(__ post(r21, 4)));     //	ld1r	{v5.4S}, [x21], 4
    __ ld1r(v10, __ T1D, Address(__ post(r28, r18)));  //	ld1r	{v10.1D}, [x28], x18
    __ ld2(v26, v27, __ T2D, Address(r15));            //	ld2	{v26.2D, v27.2D}, [x15]
    __ ld2(v16, v17, __ T4H, Address(__ post(r26, 16))); //	ld2	{v16.4H, v17.4H}, [x26], 16
    __ ld2r(v14, v15, __ T16B, Address(r2));           //	ld2r	{v14.16B, v15.16B}, [x2]
    __ ld2r(v18, v19, __ T2S, Address(__ post(r28, 8))); //	ld2r	{v18.2S, v19.2S}, [x28], 8
    __ ld2r(v19, v20, __ T2D, Address(__ post(r0, r22))); //	ld2r	{v19.2D, v20.2D}, [x0], x22
    __ ld3(v16, v17, v18, __ T4S, Address(__ post(r2, r18))); //	ld3	{v16.4S, v17.4S, v18.4S}, [x2], x18
    __ ld3(v24, v25, v26, __ T2S, Address(r0));        //	ld3	{v24.2S, v25.2S, v26.2S}, [x0]
    __ ld3r(v4, v5, v6, __ T8H, Address(r16));         //	ld3r	{v4.8H, v5.8H, v6.8H}, [x16]
    __ ld3r(v5, v6, v7, __ T4S, Address(__ post(r1, 12))); //	ld3r	{v5.4S, v6.4S, v7.4S}, [x1], 12
    __ ld3r(v7, v8, v9, __ T1D, Address(__ post(r10, r16))); //	ld3r	{v7.1D, v8.1D, v9.1D}, [x10], x16
    __ ld4(v22, v23, v24, v25, __ T8H, Address(__ post(r20, 64))); //	ld4	{v22.8H, v23.8H, v24.8H, v25.8H}, [x20], 64
    __ ld4(v15, v16, v17, v18, __ T8B, Address(__ post(r4, r25))); //	ld4	{v15.8B, v16.8B, v17.8B, v18.8B}, [x4], x25
    __ ld4r(v0, v1, v2, v3, __ T8B, Address(r5));      //	ld4r	{v0.8B, v1.8B, v2.8B, v3.8B}, [x5]
    __ ld4r(v0, v1, v2, v3, __ T4H, Address(__ post(r1, 8))); //	ld4r	{v0.4H, v1.4H, v2.4H, v3.4H}, [x1], 8
    __ ld4r(v30, v31, v0, v1, __ T2S, Address(__ post(r28, r14))); //	ld4r	{v30.2S, v31.2S, v0.2S, v1.2S}, [x28], x14

// SpecialCases
    __ ccmn(zr, zr, 3u, Assembler::LE);                //	ccmn	xzr, xzr, #3, LE
    __ ccmnw(zr, zr, 5u, Assembler::EQ);               //	ccmn	wzr, wzr, #5, EQ
    __ ccmp(zr, 1, 4u, Assembler::NE);                 //	ccmp	xzr, 1, #4, NE
    __ ccmpw(zr, 2, 2, Assembler::GT);                 //	ccmp	wzr, 2, #2, GT
    __ extr(zr, zr, zr, 0);                            //	extr	xzr, xzr, xzr, 0
    __ stlxp(r0, zr, zr, sp);                          //	stlxp	w0, xzr, xzr, [sp]
    __ stlxpw(r2, zr, zr, r3);                         //	stlxp	w2, wzr, wzr, [x3]
    __ stxp(r4, zr, zr, r5);                           //	stxp	w4, xzr, xzr, [x5]
    __ stxpw(r6, zr, zr, sp);                          //	stxp	w6, wzr, wzr, [sp]
    __ dup(v0, __ T16B, zr);                           //	dup	v0.16b, wzr
    __ mov(v1, __ T1D, 0, zr);                         //	mov	v1.d[0], xzr
    __ mov(v1, __ T2S, 1, zr);                         //	mov	v1.s[1], wzr
    __ mov(v1, __ T4H, 2, zr);                         //	mov	v1.h[2], wzr
    __ mov(v1, __ T8B, 3, zr);                         //	mov	v1.b[3], wzr
    __ ld1(v31, v0, __ T2D, Address(__ post(r1, r0))); //	ld1	{v31.2d, v0.2d}, [x1], x0

// FloatImmediateOp
    __ fmovd(v0, 2.0);                                 //	fmov d0, #2.0
    __ fmovd(v0, 2.125);                               //	fmov d0, #2.125
    __ fmovd(v0, 4.0);                                 //	fmov d0, #4.0
    __ fmovd(v0, 4.25);                                //	fmov d0, #4.25
    __ fmovd(v0, 8.0);                                 //	fmov d0, #8.0
    __ fmovd(v0, 8.5);                                 //	fmov d0, #8.5
    __ fmovd(v0, 16.0);                                //	fmov d0, #16.0
    __ fmovd(v0, 17.0);                                //	fmov d0, #17.0
    __ fmovd(v0, 0.125);                               //	fmov d0, #0.125
    __ fmovd(v0, 0.1328125);                           //	fmov d0, #0.1328125
    __ fmovd(v0, 0.25);                                //	fmov d0, #0.25
    __ fmovd(v0, 0.265625);                            //	fmov d0, #0.265625
    __ fmovd(v0, 0.5);                                 //	fmov d0, #0.5
    __ fmovd(v0, 0.53125);                             //	fmov d0, #0.53125
    __ fmovd(v0, 1.0);                                 //	fmov d0, #1.0
    __ fmovd(v0, 1.0625);                              //	fmov d0, #1.0625
    __ fmovd(v0, -2.0);                                //	fmov d0, #-2.0
    __ fmovd(v0, -2.125);                              //	fmov d0, #-2.125
    __ fmovd(v0, -4.0);                                //	fmov d0, #-4.0
    __ fmovd(v0, -4.25);                               //	fmov d0, #-4.25
    __ fmovd(v0, -8.0);                                //	fmov d0, #-8.0
    __ fmovd(v0, -8.5);                                //	fmov d0, #-8.5
    __ fmovd(v0, -16.0);                               //	fmov d0, #-16.0
    __ fmovd(v0, -17.0);                               //	fmov d0, #-17.0
    __ fmovd(v0, -0.125);                              //	fmov d0, #-0.125
    __ fmovd(v0, -0.1328125);                          //	fmov d0, #-0.1328125
    __ fmovd(v0, -0.25);                               //	fmov d0, #-0.25
    __ fmovd(v0, -0.265625);                           //	fmov d0, #-0.265625
    __ fmovd(v0, -0.5);                                //	fmov d0, #-0.5
    __ fmovd(v0, -0.53125);                            //	fmov d0, #-0.53125
    __ fmovd(v0, -1.0);                                //	fmov d0, #-1.0
    __ fmovd(v0, -1.0625);                             //	fmov d0, #-1.0625

// LSEOp
    __ swp(Assembler::xword, r26, r9, r17);            //	swp	x26, x9, [x17]
    __ ldadd(Assembler::xword, r28, r23, r2);          //	ldadd	x28, x23, [x2]
    __ ldbic(Assembler::xword, r22, r2, r3);           //	ldclr	x22, x2, [x3]
    __ ldeor(Assembler::xword, r11, r25, r30);         //	ldeor	x11, x25, [x30]
    __ ldorr(Assembler::xword, r22, r28, r4);          //	ldset	x22, x28, [x4]
    __ ldsmin(Assembler::xword, r6, r11, r24);         //	ldsmin	x6, x11, [x24]
    __ ldsmax(Assembler::xword, r12, zr, sp);          //	ldsmax	x12, xzr, [sp]
    __ ldumin(Assembler::xword, r23, r30, r9);         //	ldumin	x23, x30, [x9]
    __ ldumax(Assembler::xword, r6, r1, r20);          //	ldumax	x6, x1, [x20]

// LSEOp
    __ swpa(Assembler::xword, r17, r2, r22);           //	swpa	x17, x2, [x22]
    __ ldadda(Assembler::xword, r14, r27, r10);        //	ldadda	x14, x27, [x10]
    __ ldbica(Assembler::xword, r6, r30, r19);         //	ldclra	x6, x30, [x19]
    __ ldeora(Assembler::xword, r0, r25, r11);         //	ldeora	x0, x25, [x11]
    __ ldorra(Assembler::xword, r23, r0, r30);         //	ldseta	x23, x0, [x30]
    __ ldsmina(Assembler::xword, r21, r3, r10);        //	ldsmina	x21, x3, [x10]
    __ ldsmaxa(Assembler::xword, r15, r22, r0);        //	ldsmaxa	x15, x22, [x0]
    __ ldumina(Assembler::xword, r17, r0, r20);        //	ldumina	x17, x0, [x20]
    __ ldumaxa(Assembler::xword, r16, r13, r1);        //	ldumaxa	x16, x13, [x1]

// LSEOp
    __ swpal(Assembler::xword, r27, r15, r23);         //	swpal	x27, x15, [x23]
    __ ldaddal(Assembler::xword, r19, r30, r1);        //	ldaddal	x19, x30, [x1]
    __ ldbical(Assembler::xword, r15, r28, r23);       //	ldclral	x15, x28, [x23]
    __ ldeoral(Assembler::xword, r7, r15, r19);        //	ldeoral	x7, x15, [x19]
    __ ldorral(Assembler::xword, r11, r12, r10);       //	ldsetal	x11, x12, [x10]
    __ ldsminal(Assembler::xword, r6, r7, r12);        //	ldsminal	x6, x7, [x12]
    __ ldsmaxal(Assembler::xword, r28, r5, r13);       //	ldsmaxal	x28, x5, [x13]
    __ lduminal(Assembler::xword, r9, r20, r17);       //	lduminal	x9, x20, [x17]
    __ ldumaxal(Assembler::xword, r21, r25, r11);      //	ldumaxal	x21, x25, [x11]

// LSEOp
    __ swpl(Assembler::xword, r19, r24, r24);          //	swpl	x19, x24, [x24]
    __ ldaddl(Assembler::xword, r8, r26, r30);         //	ldaddl	x8, x26, [x30]
    __ ldbicl(Assembler::xword, r17, r18, r8);         //	ldclrl	x17, x18, [x8]
    __ ldeorl(Assembler::xword, r2, r3, r3);           //	ldeorl	x2, x3, [x3]
    __ ldorrl(Assembler::xword, r26, r7, r16);         //	ldsetl	x26, x7, [x16]
    __ ldsminl(Assembler::xword, r27, r6, r5);         //	ldsminl	x27, x6, [x5]
    __ ldsmaxl(Assembler::xword, r22, r0, r20);        //	ldsmaxl	x22, x0, [x20]
    __ lduminl(Assembler::xword, r11, r26, r2);        //	lduminl	x11, x26, [x2]
    __ ldumaxl(Assembler::xword, r30, r29, r4);        //	ldumaxl	x30, x29, [x4]

// LSEOp
    __ swp(Assembler::word, r4, r5, r7);               //	swp	w4, w5, [x7]
    __ ldadd(Assembler::word, r10, r26, r2);           //	ldadd	w10, w26, [x2]
    __ ldbic(Assembler::word, r27, r16, r27);          //	ldclr	w27, w16, [x27]
    __ ldeor(Assembler::word, zr, r23, r10);           //	ldeor	wzr, w23, [x10]
    __ ldorr(Assembler::word, r4, r2, r13);            //	ldset	w4, w2, [x13]
    __ ldsmin(Assembler::word, r3, r15, r3);           //	ldsmin	w3, w15, [x3]
    __ ldsmax(Assembler::word, r3, r10, r6);           //	ldsmax	w3, w10, [x6]
    __ ldumin(Assembler::word, r8, r11, r10);          //	ldumin	w8, w11, [x10]
    __ ldumax(Assembler::word, r29, r30, r13);         //	ldumax	w29, w30, [x13]

// LSEOp
    __ swpa(Assembler::word, r11, r17, r20);           //	swpa	w11, w17, [x20]
    __ ldadda(Assembler::word, r26, r16, r6);          //	ldadda	w26, w16, [x6]
    __ ldbica(Assembler::word, r21, r10, r1);          //	ldclra	w21, w10, [x1]
    __ ldeora(Assembler::word, r29, r12, r23);         //	ldeora	w29, w12, [x23]
    __ ldorra(Assembler::word, r29, r8, r8);           //	ldseta	w29, w8, [x8]
    __ ldsmina(Assembler::word, r11, r10, r14);        //	ldsmina	w11, w10, [x14]
    __ ldsmaxa(Assembler::word, r4, r13, r22);         //	ldsmaxa	w4, w13, [x22]
    __ ldumina(Assembler::word, r7, r13, r7);          //	ldumina	w7, w13, [x7]
    __ ldumaxa(Assembler::word, r14, r0, sp);          //	ldumaxa	w14, w0, [sp]

// LSEOp
    __ swpal(Assembler::word, r17, r2, r28);           //	swpal	w17, w2, [x28]
    __ ldaddal(Assembler::word, r19, r11, r10);        //	ldaddal	w19, w11, [x10]
    __ ldbical(Assembler::word, r12, r19, r20);        //	ldclral	w12, w19, [x20]
    __ ldeoral(Assembler::word, r0, r8, r8);           //	ldeoral	w0, w8, [x8]
    __ ldorral(Assembler::word, r17, r3, r24);         //	ldsetal	w17, w3, [x24]
    __ ldsminal(Assembler::word, r25, r5, r7);         //	ldsminal	w25, w5, [x7]
    __ ldsmaxal(Assembler::word, r16, r30, r9);        //	ldsmaxal	w16, w30, [x9]
    __ lduminal(Assembler::word, r10, zr, r14);        //	lduminal	w10, wzr, [x14]
    __ ldumaxal(Assembler::word, r17, r19, r11);       //	ldumaxal	w17, w19, [x11]

// LSEOp
    __ swpl(Assembler::word, r20, r1, r13);            //	swpl	w20, w1, [x13]
    __ ldaddl(Assembler::word, r26, r11, r20);         //	ldaddl	w26, w11, [x20]
    __ ldbicl(Assembler::word, r18, r24, r30);         //	ldclrl	w18, w24, [x30]
    __ ldeorl(Assembler::word, r12, r25, r20);         //	ldeorl	w12, w25, [x20]
    __ ldorrl(Assembler::word, r14, r29, r5);          //	ldsetl	w14, w29, [x5]
    __ ldsminl(Assembler::word, r2, r26, r27);         //	ldsminl	w2, w26, [x27]
    __ ldsmaxl(Assembler::word, r25, r27, r11);        //	ldsmaxl	w25, w27, [x11]
    __ lduminl(Assembler::word, r4, r29, r7);          //	lduminl	w4, w29, [x7]
    __ ldumaxl(Assembler::word, r16, r29, r10);        //	ldumaxl	w16, w29, [x10]

    __ bind(forth);

/*
aarch64ops.o:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000000000 <back>:
   0:	8b4db437 	add	x23, x1, x13, lsr #45
   4:	cb8ce3c8 	sub	x8, x30, x12, asr #56
   8:	ab0edafb 	adds	x27, x23, x14, lsl #54
   c:	eb5499f5 	subs	x21, x15, x20, lsr #38
  10:	0b040e39 	add	w25, w17, w4, lsl #3
  14:	4b89503d 	sub	w29, w1, w9, asr #20
  18:	2b89274a 	adds	w10, w26, w9, asr #9
  1c:	6b870fd5 	subs	w21, w30, w7, asr #3
  20:	8a4b1109 	and	x9, x8, x11, lsr #4
  24:	aa810643 	orr	x3, x18, x1, asr #1
  28:	ca026e8a 	eor	x10, x20, x2, lsl #27
  2c:	ea8b7d2c 	ands	x12, x9, x11, asr #31
  30:	0a9e6934 	and	w20, w9, w30, asr #26
  34:	2a9a4555 	orr	w21, w10, w26, asr #17
  38:	4a871d00 	eor	w0, w8, w7, asr #7
  3c:	6a084973 	ands	w19, w11, w8, lsl #18
  40:	8a23d497 	bic	x23, x4, x3, lsl #53
  44:	aa3360c9 	orn	x9, x6, x19, lsl #24
  48:	ca7ad8cc 	eon	x12, x6, x26, lsr #54
  4c:	ea2c3a76 	bics	x22, x19, x12, lsl #14
  50:	0a362dbd 	bic	w29, w13, w22, lsl #11
  54:	2ab417d1 	orn	w17, w30, w20, asr #5
  58:	4a2b23a1 	eon	w1, w29, w11, lsl #8
  5c:	6a667684 	bics	w4, w20, w6, lsr #29
  60:	1107e0de 	add	w30, w6, #0x1f8
  64:	310ebd13 	adds	w19, w8, #0x3af
  68:	5105b55d 	sub	w29, w10, #0x16d
  6c:	71047104 	subs	w4, w8, #0x11c
  70:	910ef9c3 	add	x3, x14, #0x3be
  74:	b1029e96 	adds	x22, x20, #0xa7
  78:	d10b55fb 	sub	x27, x15, #0x2d5
  7c:	f10ecf98 	subs	x24, x28, #0x3b3
  80:	12099f39 	and	w25, w25, #0x7f807f80
  84:	321b3f4d 	orr	w13, w26, #0x1fffe0
  88:	520309b5 	eor	w21, w13, #0xe0000000
  8c:	72134062 	ands	w2, w3, #0x3fffe000
  90:	92004548 	and	x8, x10, #0x3ffff0003ffff
  94:	b24d861b 	orr	x27, x16, #0xfff80000001fffff
  98:	d219587b 	eor	x27, x3, #0x3fffff803fffff80
  9c:	f25eaee4 	ands	x4, x23, #0xfffffffc00003fff
  a0:	14000000 	b	a0 <back+0xa0>
  a4:	17ffffd7 	b	0 <back>
  a8:	140001ee 	b	860 <forth>
  ac:	94000000 	bl	ac <back+0xac>
  b0:	97ffffd4 	bl	0 <back>
  b4:	940001eb 	bl	860 <forth>
  b8:	34000003 	cbz	w3, b8 <back+0xb8>
  bc:	34fffa23 	cbz	w3, 0 <back>
  c0:	34003d03 	cbz	w3, 860 <forth>
  c4:	35000002 	cbnz	w2, c4 <back+0xc4>
  c8:	35fff9c2 	cbnz	w2, 0 <back>
  cc:	35003ca2 	cbnz	w2, 860 <forth>
  d0:	b4000019 	cbz	x25, d0 <back+0xd0>
  d4:	b4fff979 	cbz	x25, 0 <back>
  d8:	b4003c59 	cbz	x25, 860 <forth>
  dc:	b5000012 	cbnz	x18, dc <back+0xdc>
  e0:	b5fff912 	cbnz	x18, 0 <back>
  e4:	b5003bf2 	cbnz	x18, 860 <forth>
  e8:	10000008 	adr	x8, e8 <back+0xe8>
  ec:	10fff8a8 	adr	x8, 0 <back>
  f0:	10003b88 	adr	x8, 860 <forth>
  f4:	9000000f 	adrp	x15, 0 <back>
  f8:	36700012 	tbz	w18, #14, f8 <back+0xf8>
  fc:	3677f832 	tbz	w18, #14, 0 <back>
 100:	36703b12 	tbz	w18, #14, 860 <forth>
 104:	37780019 	tbnz	w25, #15, 104 <back+0x104>
 108:	377ff7d9 	tbnz	w25, #15, 0 <back>
 10c:	37783ab9 	tbnz	w25, #15, 860 <forth>
 110:	12a203d2 	mov	w18, #0xefe1ffff            	// #-270401537
 114:	5286b21e 	mov	w30, #0x3590                	// #13712
 118:	72a66d35 	movk	w21, #0x3369, lsl #16
 11c:	92eded92 	mov	x18, #0x9093ffffffffffff    	// #-8028792235694751745
 120:	d2eefecd 	mov	x13, #0x77f6000000000000    	// #8644096534784245760
 124:	f2ef69a3 	movk	x3, #0x7b4d, lsl #48
 128:	93400c2a 	sbfx	x10, x1, #0, #4
 12c:	330562cc 	bfxil	w12, w22, #5, #20
 130:	530b2071 	ubfiz	w17, w3, #21, #9
 134:	934b3860 	sbfx	x0, x3, #11, #4
 138:	b3473cdc 	bfxil	x28, x6, #7, #9
 13c:	d3416549 	ubfx	x9, x10, #1, #25
 140:	13995f75 	extr	w21, w27, w25, #23
 144:	93d6462e 	extr	x14, x17, x22, #17
 148:	54000000 	b.eq	148 <back+0x148>  // b.none
 14c:	54fff5a0 	b.eq	0 <back>  // b.none
 150:	54003880 	b.eq	860 <forth>  // b.none
 154:	54000001 	b.ne	154 <back+0x154>  // b.any
 158:	54fff541 	b.ne	0 <back>  // b.any
 15c:	54003821 	b.ne	860 <forth>  // b.any
 160:	54000002 	b.cs	160 <back+0x160>  // b.hs, b.nlast
 164:	54fff4e2 	b.cs	0 <back>  // b.hs, b.nlast
 168:	540037c2 	b.cs	860 <forth>  // b.hs, b.nlast
 16c:	54000002 	b.cs	16c <back+0x16c>  // b.hs, b.nlast
 170:	54fff482 	b.cs	0 <back>  // b.hs, b.nlast
 174:	54003762 	b.cs	860 <forth>  // b.hs, b.nlast
 178:	54000003 	b.cc	178 <back+0x178>  // b.lo, b.ul, b.last
 17c:	54fff423 	b.cc	0 <back>  // b.lo, b.ul, b.last
 180:	54003703 	b.cc	860 <forth>  // b.lo, b.ul, b.last
 184:	54000003 	b.cc	184 <back+0x184>  // b.lo, b.ul, b.last
 188:	54fff3c3 	b.cc	0 <back>  // b.lo, b.ul, b.last
 18c:	540036a3 	b.cc	860 <forth>  // b.lo, b.ul, b.last
 190:	54000004 	b.mi	190 <back+0x190>  // b.first
 194:	54fff364 	b.mi	0 <back>  // b.first
 198:	54003644 	b.mi	860 <forth>  // b.first
 19c:	54000005 	b.pl	19c <back+0x19c>  // b.nfrst
 1a0:	54fff305 	b.pl	0 <back>  // b.nfrst
 1a4:	540035e5 	b.pl	860 <forth>  // b.nfrst
 1a8:	54000006 	b.vs	1a8 <back+0x1a8>
 1ac:	54fff2a6 	b.vs	0 <back>
 1b0:	54003586 	b.vs	860 <forth>
 1b4:	54000007 	b.vc	1b4 <back+0x1b4>
 1b8:	54fff247 	b.vc	0 <back>
 1bc:	54003527 	b.vc	860 <forth>
 1c0:	54000008 	b.hi	1c0 <back+0x1c0>  // b.pmore
 1c4:	54fff1e8 	b.hi	0 <back>  // b.pmore
 1c8:	540034c8 	b.hi	860 <forth>  // b.pmore
 1cc:	54000009 	b.ls	1cc <back+0x1cc>  // b.plast
 1d0:	54fff189 	b.ls	0 <back>  // b.plast
 1d4:	54003469 	b.ls	860 <forth>  // b.plast
 1d8:	5400000a 	b.ge	1d8 <back+0x1d8>  // b.tcont
 1dc:	54fff12a 	b.ge	0 <back>  // b.tcont
 1e0:	5400340a 	b.ge	860 <forth>  // b.tcont
 1e4:	5400000b 	b.lt	1e4 <back+0x1e4>  // b.tstop
 1e8:	54fff0cb 	b.lt	0 <back>  // b.tstop
 1ec:	540033ab 	b.lt	860 <forth>  // b.tstop
 1f0:	5400000c 	b.gt	1f0 <back+0x1f0>
 1f4:	54fff06c 	b.gt	0 <back>
 1f8:	5400334c 	b.gt	860 <forth>
 1fc:	5400000d 	b.le	1fc <back+0x1fc>
 200:	54fff00d 	b.le	0 <back>
 204:	540032ed 	b.le	860 <forth>
 208:	5400000e 	b.al	208 <back+0x208>
 20c:	54ffefae 	b.al	0 <back>
 210:	5400328e 	b.al	860 <forth>
 214:	5400000f 	b.nv	214 <back+0x214>
 218:	54ffef4f 	b.nv	0 <back>
 21c:	5400322f 	b.nv	860 <forth>
 220:	d40f9ca1 	svc	#0x7ce5
 224:	d4008b22 	hvc	#0x459
 228:	d40be1c3 	smc	#0x5f0e
 22c:	d423d0e0 	brk	#0x1e87
 230:	d44dee20 	hlt	#0x6f71
 234:	d503201f 	nop
 238:	d69f03e0 	eret
 23c:	d6bf03e0 	drps
 240:	d5033fdf 	isb
 244:	d503359f 	dsb	nshld
 248:	d50337bf 	dmb	nsh
 24c:	d61f0380 	br	x28
 250:	d63f0220 	blr	x17
 254:	c8127f47 	stxr	w18, x7, [x26]
 258:	c819fccc 	stlxr	w25, x12, [x6]
 25c:	c85f7e00 	ldxr	x0, [x16]
 260:	c85ffc66 	ldaxr	x6, [x3]
 264:	c89ffc2e 	stlr	x14, [x1]
 268:	c8dfff1d 	ldar	x29, [x24]
 26c:	881c7eef 	stxr	w28, w15, [x23]
 270:	8809fc67 	stlxr	w9, w7, [x3]
 274:	885f7e81 	ldxr	w1, [x20]
 278:	885ffdf4 	ldaxr	w20, [x15]
 27c:	889ffd35 	stlr	w21, [x9]
 280:	88dffe25 	ldar	w5, [x17]
 284:	480d7fd4 	stxrh	w13, w20, [x30]
 288:	480afe4c 	stlxrh	w10, w12, [x18]
 28c:	485f7e64 	ldxrh	w4, [x19]
 290:	485ffd56 	ldaxrh	w22, [x10]
 294:	489ffdfe 	stlrh	w30, [x15]
 298:	48dfff04 	ldarh	w4, [x24]
 29c:	080a7d94 	stxrb	w10, w20, [x12]
 2a0:	0814fd7d 	stlxrb	w20, w29, [x11]
 2a4:	085f7cb5 	ldxrb	w21, [x5]
 2a8:	085ffd24 	ldaxrb	w4, [x9]
 2ac:	089fff9e 	stlrb	w30, [x28]
 2b0:	08dfff13 	ldarb	w19, [x24]
 2b4:	c87f424b 	ldxp	x11, x16, [x18]
 2b8:	c87f9de8 	ldaxp	x8, x7, [x15]
 2bc:	c83c4154 	stxp	w28, x20, x16, [x10]
 2c0:	c827d469 	stlxp	w7, x9, x21, [x3]
 2c4:	887f1a79 	ldxp	w25, w6, [x19]
 2c8:	887fa45e 	ldaxp	w30, w9, [x2]
 2cc:	88305180 	stxp	w16, w0, w20, [x12]
 2d0:	88259f82 	stlxp	w5, w2, w7, [x28]
 2d4:	f81b5270 	stur	x16, [x19, #-75]
 2d8:	b801e381 	stur	w1, [x28, #30]
 2dc:	381e61bc 	sturb	w28, [x13, #-26]
 2e0:	781cd0c8 	sturh	w8, [x6, #-51]
 2e4:	f851d380 	ldur	x0, [x28, #-227]
 2e8:	b85e615c 	ldur	w28, [x10, #-26]
 2ec:	39403164 	ldrb	w4, [x11, #12]
 2f0:	78405221 	ldurh	w1, [x17, #5]
 2f4:	3980312b 	ldrsb	x11, [x9, #12]
 2f8:	789ef108 	ldursh	x8, [x8, #-17]
 2fc:	78ddd1b4 	ldursh	w20, [x13, #-35]
 300:	b8831137 	ldursw	x23, [x9, #49]
 304:	fc41d089 	ldur	d9, [x4, #29]
 308:	bd402a6b 	ldr	s11, [x19, #40]
 30c:	fc1d5299 	stur	d25, [x20, #-43]
 310:	bc1b0039 	stur	s25, [x1, #-80]
 314:	f8019c14 	str	x20, [x0, #25]!
 318:	b81cfd8c 	str	w12, [x12, #-49]!
 31c:	381f6e7c 	strb	w28, [x19, #-10]!
 320:	781c1f8d 	strh	w13, [x28, #-63]!
 324:	f85d2eeb 	ldr	x11, [x23, #-46]!
 328:	b8411f1b 	ldr	w27, [x24, #17]!
 32c:	385f4f4e 	ldrb	w14, [x26, #-12]!
 330:	785d3ed8 	ldrh	w24, [x22, #-45]!
 334:	389f5d39 	ldrsb	x25, [x9, #-11]!
 338:	7881dcc5 	ldrsh	x5, [x6, #29]!
 33c:	78dffee7 	ldrsh	w7, [x23, #-1]!
 340:	b89c3dba 	ldrsw	x26, [x13, #-61]!
 344:	fc50bf18 	ldr	d24, [x24, #-245]!
 348:	bc5c9f34 	ldr	s20, [x25, #-55]!
 34c:	fc135c49 	str	d9, [x2, #-203]!
 350:	bc1c5c2e 	str	s14, [x1, #-59]!
 354:	f806d433 	str	x19, [x1], #109
 358:	b81ca4a4 	str	w4, [x5], #-54
 35c:	3800947d 	strb	w29, [x3], #9
 360:	781ce420 	strh	w0, [x1], #-50
 364:	f85d04c2 	ldr	x2, [x6], #-48
 368:	b858d4cf 	ldr	w15, [x6], #-115
 36c:	385e5444 	ldrb	w4, [x2], #-27
 370:	785eb751 	ldrh	w17, [x26], #-21
 374:	389f3715 	ldrsb	x21, [x24], #-13
 378:	789d04d6 	ldrsh	x22, [x6], #-48
 37c:	78dd04cb 	ldrsh	w11, [x6], #-48
 380:	b89fb7ce 	ldrsw	x14, [x30], #-5
 384:	fc5975e2 	ldr	d2, [x15], #-105
 388:	bc5a5679 	ldr	s25, [x19], #-91
 38c:	fc1416ed 	str	d13, [x23], #-191
 390:	bc0006b6 	str	s22, [x21], #0
 394:	f832c996 	str	x22, [x12, w18, sxtw]
 398:	b82c4b7e 	str	w30, [x27, w12, uxtw]
 39c:	38367887 	strb	w7, [x4, x22, lsl #0]
 3a0:	783dfaf3 	strh	w19, [x23, x29, sxtx #1]
 3a4:	f87bf891 	ldr	x17, [x4, x27, sxtx #3]
 3a8:	b871c9a1 	ldr	w1, [x13, w17, sxtw]
 3ac:	387dfb70 	ldrb	w16, [x27, x29, sxtx #0]
 3b0:	78645939 	ldrh	w25, [x9, w4, uxtw #1]
 3b4:	38b67984 	ldrsb	x4, [x12, x22, lsl #0]
 3b8:	78a55839 	ldrsh	x25, [x1, w5, uxtw #1]
 3bc:	78fc6a09 	ldrsh	w9, [x16, x28]
 3c0:	b8aee8e8 	ldrsw	x8, [x7, x14, sxtx]
 3c4:	fc705b84 	ldr	d4, [x28, w16, uxtw #3]
 3c8:	bc7bd850 	ldr	s16, [x2, w27, sxtw #2]
 3cc:	fc396817 	str	d23, [x0, x25]
 3d0:	bc277a06 	str	s6, [x16, x7, lsl #2]
 3d4:	f91ddd82 	str	x2, [x12, #15288]
 3d8:	b91b10a8 	str	w8, [x5, #6928]
 3dc:	391f8221 	strb	w1, [x17, #2016]
 3e0:	79197728 	strh	w8, [x25, #3258]
 3e4:	f95ca07c 	ldr	x28, [x3, #14656]
 3e8:	b95b5d75 	ldr	w21, [x11, #7004]
 3ec:	395dc8af 	ldrb	w15, [x5, #1906]
 3f0:	795caa60 	ldrh	w0, [x19, #3668]
 3f4:	399dd53d 	ldrsb	x29, [x9, #1909]
 3f8:	799c7397 	ldrsh	x23, [x28, #3640]
 3fc:	79dcb15b 	ldrsh	w27, [x10, #3672]
 400:	b99e3b75 	ldrsw	x21, [x27, #7736]
 404:	fd5c7f7a 	ldr	d26, [x27, #14584]
 408:	bd5d2882 	ldr	s2, [x4, #7464]
 40c:	fd1fb2a1 	str	d1, [x21, #16224]
 410:	bd1d82c4 	str	s4, [x22, #7552]
 414:	58000001 	ldr	x1, 414 <back+0x414>
 418:	1800001b 	ldr	w27, 418 <back+0x418>
 41c:	f882d080 	prfum	pldl1keep, [x4, #45]
 420:	d8000000 	prfm	pldl1keep, 420 <back+0x420>
 424:	f8a0cbc0 	prfm	pldl1keep, [x30, w0, sxtw]
 428:	f99fab00 	prfm	pldl1keep, [x24, #16208]
 42c:	1a1803a0 	adc	w0, w29, w24
 430:	3a120396 	adcs	w22, w28, w18
 434:	5a1e0217 	sbc	w23, w16, w30
 438:	7a0e03a7 	sbcs	w7, w29, w14
 43c:	9a0e0196 	adc	x22, x12, x14
 440:	ba17031d 	adcs	x29, x24, x23
 444:	da160391 	sbc	x17, x28, x22
 448:	fa130298 	sbcs	x24, x20, x19
 44c:	0b26cadb 	add	w27, w22, w6, sxtw #2
 450:	2b38516d 	adds	w13, w11, w24, uxtw #4
 454:	cb242d10 	sub	x16, x8, w4, uxth #3
 458:	6b34ea55 	subs	w21, w18, w20, sxtx #2
 45c:	8b3d0a2e 	add	x14, x17, w29, uxtb #2
 460:	ab2eb231 	adds	x17, x17, w14, sxth #4
 464:	cb3ac476 	sub	x22, x3, w26, sxtw #1
 468:	eb3531ad 	subs	x13, x13, w21, uxth #4
 46c:	3a5a722f 	ccmn	w17, w26, #0xf, vc
 470:	7a463325 	ccmp	w25, w6, #0x5, cc  // cc = lo, ul, last
 474:	ba5e9021 	ccmn	x1, x30, #0x1, ls  // ls = plast
 478:	fa47a222 	ccmp	x17, x7, #0x2, ge  // ge = tcont
 47c:	3a590a26 	ccmn	w17, #0x19, #0x6, eq  // eq = none
 480:	7a450845 	ccmp	w2, #0x5, #0x5, eq  // eq = none
 484:	ba514a6a 	ccmn	x19, #0x11, #0xa, mi  // mi = first
 488:	fa48c9c3 	ccmp	x14, #0x8, #0x3, gt
 48c:	1a8e9109 	csel	w9, w8, w14, ls  // ls = plast
 490:	1a85d57b 	csinc	w27, w11, w5, le
 494:	5a9632eb 	csinv	w11, w23, w22, cc  // cc = lo, ul, last
 498:	5a9b2793 	csneg	w19, w28, w27, cs  // cs = hs, nlast
 49c:	9a815130 	csel	x16, x9, x1, pl  // pl = nfrst
 4a0:	9a8c05dc 	csinc	x28, x14, x12, eq  // eq = none
 4a4:	da8e5096 	csinv	x22, x4, x14, pl  // pl = nfrst
 4a8:	da9b257a 	csneg	x26, x11, x27, cs  // cs = hs, nlast
 4ac:	5ac00178 	rbit	w24, w11
 4b0:	5ac005ca 	rev16	w10, w14
 4b4:	5ac008a9 	rev	w9, w5
 4b8:	5ac01292 	clz	w18, w20
 4bc:	5ac01519 	cls	w25, w8
 4c0:	dac00316 	rbit	x22, x24
 4c4:	dac0077c 	rev16	x28, x27
 4c8:	dac00ba8 	rev32	x8, x29
 4cc:	dac00d51 	rev	x17, x10
 4d0:	dac01177 	clz	x23, x11
 4d4:	dac015da 	cls	x26, x14
 4d8:	1adc0895 	udiv	w21, w4, w28
 4dc:	1ad60d5e 	sdiv	w30, w10, w22
 4e0:	1ada205d 	lsl	w29, w2, w26
 4e4:	1aca26dc 	lsr	w28, w22, w10
 4e8:	1acc2b0b 	asr	w11, w24, w12
 4ec:	1ad02fd5 	ror	w21, w30, w16
 4f0:	9acd0801 	udiv	x1, x0, x13
 4f4:	9ac60e22 	sdiv	x2, x17, x6
 4f8:	9ad5230a 	lsl	x10, x24, x21
 4fc:	9ac62525 	lsr	x5, x9, x6
 500:	9ac42b60 	asr	x0, x27, x4
 504:	9ac22c9c 	ror	x28, x4, x2
 508:	9bc77fc1 	umulh	x1, x30, x7
 50c:	9b4a7cbe 	smulh	x30, x5, x10
 510:	1b0d45e7 	madd	w7, w15, w13, w17
 514:	1b0cf039 	msub	w25, w1, w12, w28
 518:	9b1e2562 	madd	x2, x11, x30, x9
 51c:	9b03dae5 	msub	x5, x23, x3, x22
 520:	9b291159 	smaddl	x25, w10, w9, x4
 524:	9b27c905 	smsubl	x5, w8, w7, x18
 528:	9bba64b8 	umaddl	x24, w5, w26, x25
 52c:	9bbaf02e 	umsubl	x14, w1, w26, x28
 530:	1e280ad8 	fmul	s24, s22, s8
 534:	1e261870 	fdiv	s16, s3, s6
 538:	1e392ab0 	fadd	s16, s21, s25
 53c:	1e3b3b40 	fsub	s0, s26, s27
 540:	1e310878 	fmul	s24, s3, s17
 544:	1e660909 	fmul	d9, d8, d6
 548:	1e7e1a76 	fdiv	d22, d19, d30
 54c:	1e632a2e 	fadd	d14, d17, d3
 550:	1e743b78 	fsub	d24, d27, d20
 554:	1e76082c 	fmul	d12, d1, d22
 558:	1f0b7510 	fmadd	s16, s8, s11, s29
 55c:	1f128676 	fmsub	s22, s19, s18, s1
 560:	1f38270f 	fnmadd	s15, s24, s24, s9
 564:	1f2d5e7b 	fnmadd	s27, s19, s13, s23
 568:	1f503003 	fmadd	d3, d0, d16, d12
 56c:	1f52a873 	fmsub	d19, d3, d18, d10
 570:	1f6b5041 	fnmadd	d1, d2, d11, d20
 574:	1f79392c 	fnmadd	d12, d9, d25, d14
 578:	1e2042e0 	fmov	s0, s23
 57c:	1e20c0d7 	fabs	s23, s6
 580:	1e214084 	fneg	s4, s4
 584:	1e21c385 	fsqrt	s5, s28
 588:	1e22c1f5 	fcvt	d21, s15
 58c:	1e6040ab 	fmov	d11, d5
 590:	1e60c092 	fabs	d18, d4
 594:	1e61418b 	fneg	d11, d12
 598:	1e61c10f 	fsqrt	d15, d8
 59c:	1e624048 	fcvt	s8, d2
 5a0:	1e380253 	fcvtzs	w19, s18
 5a4:	9e380011 	fcvtzs	x17, s0
 5a8:	1e7801a0 	fcvtzs	w0, d13
 5ac:	9e780136 	fcvtzs	x22, d9
 5b0:	1e2203a6 	scvtf	s6, w29
 5b4:	9e2201cc 	scvtf	s12, x14
 5b8:	1e6202d0 	scvtf	d16, w22
 5bc:	9e6200ae 	scvtf	d14, x5
 5c0:	1e260007 	fmov	w7, s0
 5c4:	9e6600dc 	fmov	x28, d6
 5c8:	1e270342 	fmov	s2, w26
 5cc:	9e670004 	fmov	d4, x0
 5d0:	1e2b2020 	fcmp	s1, s11
 5d4:	1e7520c0 	fcmp	d6, d21
 5d8:	1e202208 	fcmp	s16, #0.0
 5dc:	1e6022c8 	fcmp	d22, #0.0
 5e0:	290c0045 	stp	w5, w0, [x2, #96]
 5e4:	2978766e 	ldp	w14, w29, [x19, #-64]
 5e8:	696c0c6f 	ldpsw	x15, x3, [x3, #-160]
 5ec:	a9323767 	stp	x7, x13, [x27, #-224]
 5f0:	a9483831 	ldp	x17, x14, [x1, #128]
 5f4:	29905895 	stp	w21, w22, [x4, #128]!
 5f8:	29f43451 	ldp	w17, w13, [x2, #-96]!
 5fc:	69ee66f5 	ldpsw	x21, x25, [x23, #-144]!
 600:	a9bf41e4 	stp	x4, x16, [x15, #-16]!
 604:	a9f6573d 	ldp	x29, x21, [x25, #-160]!
 608:	288a4758 	stp	w24, w17, [x26], #80
 60c:	28e27bc3 	ldp	w3, w30, [x30], #-240
 610:	68fc4fc3 	ldpsw	x3, x19, [x30], #-32
 614:	a8b70779 	stp	x25, x1, [x27], #-144
 618:	a8fc539a 	ldp	x26, x20, [x28], #-64
 61c:	283a653d 	stnp	w29, w25, [x9, #-48]
 620:	28703a79 	ldnp	w25, w14, [x19, #-128]
 624:	a8025879 	stnp	x25, x22, [x3, #32]
 628:	a8734ba9 	ldnp	x9, x18, [x29, #-208]
 62c:	0c407275 	ld1	{v21.8b}, [x19]
 630:	4cdfa29b 	ld1	{v27.16b, v28.16b}, [x20], #32
 634:	0cc66ec5 	ld1	{v5.1d-v7.1d}, [x22], x6
 638:	4cdf2596 	ld1	{v22.8h-v25.8h}, [x12], #64
 63c:	0d40c131 	ld1r	{v17.8b}, [x9]
 640:	4ddfcaa5 	ld1r	{v5.4s}, [x21], #4
 644:	0dd2cf8a 	ld1r	{v10.1d}, [x28], x18
 648:	4c408dfa 	ld2	{v26.2d, v27.2d}, [x15]
 64c:	0cdf8750 	ld2	{v16.4h, v17.4h}, [x26], #16
 650:	4d60c04e 	ld2r	{v14.16b, v15.16b}, [x2]
 654:	0dffcb92 	ld2r	{v18.2s, v19.2s}, [x28], #8
 658:	4df6cc13 	ld2r	{v19.2d, v20.2d}, [x0], x22
 65c:	4cd24850 	ld3	{v16.4s-v18.4s}, [x2], x18
 660:	0c404818 	ld3	{v24.2s-v26.2s}, [x0]
 664:	4d40e604 	ld3r	{v4.8h-v6.8h}, [x16]
 668:	4ddfe825 	ld3r	{v5.4s-v7.4s}, [x1], #12
 66c:	0dd0ed47 	ld3r	{v7.1d-v9.1d}, [x10], x16
 670:	4cdf0696 	ld4	{v22.8h-v25.8h}, [x20], #64
 674:	0cd9008f 	ld4	{v15.8b-v18.8b}, [x4], x25
 678:	0d60e0a0 	ld4r	{v0.8b-v3.8b}, [x5]
 67c:	0dffe420 	ld4r	{v0.4h-v3.4h}, [x1], #8
 680:	0deeeb9e 	ld4r	{v30.2s, v31.2s, v0.2s, v1.2s}, [x28], x14
 684:	ba5fd3e3 	ccmn	xzr, xzr, #0x3, le
 688:	3a5f03e5 	ccmn	wzr, wzr, #0x5, eq  // eq = none
 68c:	fa411be4 	ccmp	xzr, #0x1, #0x4, ne  // ne = any
 690:	7a42cbe2 	ccmp	wzr, #0x2, #0x2, gt
 694:	93df03ff 	ror	xzr, xzr, #0
 698:	c820ffff 	stlxp	w0, xzr, xzr, [sp]
 69c:	8822fc7f 	stlxp	w2, wzr, wzr, [x3]
 6a0:	c8247cbf 	stxp	w4, xzr, xzr, [x5]
 6a4:	88267fff 	stxp	w6, wzr, wzr, [sp]
 6a8:	4e010fe0 	dup	v0.16b, wzr
 6ac:	4e081fe1 	mov	v1.d[0], xzr
 6b0:	4e0c1fe1 	mov	v1.s[1], wzr
 6b4:	4e0a1fe1 	mov	v1.h[2], wzr
 6b8:	4e071fe1 	mov	v1.b[3], wzr
 6bc:	4cc0ac3f 	ld1	{v31.2d, v0.2d}, [x1], x0
 6c0:	1e601000 	fmov	d0, #2.000000000000000000e+00
 6c4:	1e603000 	fmov	d0, #2.125000000000000000e+00
 6c8:	1e621000 	fmov	d0, #4.000000000000000000e+00
 6cc:	1e623000 	fmov	d0, #4.250000000000000000e+00
 6d0:	1e641000 	fmov	d0, #8.000000000000000000e+00
 6d4:	1e643000 	fmov	d0, #8.500000000000000000e+00
 6d8:	1e661000 	fmov	d0, #1.600000000000000000e+01
 6dc:	1e663000 	fmov	d0, #1.700000000000000000e+01
 6e0:	1e681000 	fmov	d0, #1.250000000000000000e-01
 6e4:	1e683000 	fmov	d0, #1.328125000000000000e-01
 6e8:	1e6a1000 	fmov	d0, #2.500000000000000000e-01
 6ec:	1e6a3000 	fmov	d0, #2.656250000000000000e-01
 6f0:	1e6c1000 	fmov	d0, #5.000000000000000000e-01
 6f4:	1e6c3000 	fmov	d0, #5.312500000000000000e-01
 6f8:	1e6e1000 	fmov	d0, #1.000000000000000000e+00
 6fc:	1e6e3000 	fmov	d0, #1.062500000000000000e+00
 700:	1e701000 	fmov	d0, #-2.000000000000000000e+00
 704:	1e703000 	fmov	d0, #-2.125000000000000000e+00
 708:	1e721000 	fmov	d0, #-4.000000000000000000e+00
 70c:	1e723000 	fmov	d0, #-4.250000000000000000e+00
 710:	1e741000 	fmov	d0, #-8.000000000000000000e+00
 714:	1e743000 	fmov	d0, #-8.500000000000000000e+00
 718:	1e761000 	fmov	d0, #-1.600000000000000000e+01
 71c:	1e763000 	fmov	d0, #-1.700000000000000000e+01
 720:	1e781000 	fmov	d0, #-1.250000000000000000e-01
 724:	1e783000 	fmov	d0, #-1.328125000000000000e-01
 728:	1e7a1000 	fmov	d0, #-2.500000000000000000e-01
 72c:	1e7a3000 	fmov	d0, #-2.656250000000000000e-01
 730:	1e7c1000 	fmov	d0, #-5.000000000000000000e-01
 734:	1e7c3000 	fmov	d0, #-5.312500000000000000e-01
 738:	1e7e1000 	fmov	d0, #-1.000000000000000000e+00
 73c:	1e7e3000 	fmov	d0, #-1.062500000000000000e+00
 740:	f83a8229 	swp	x26, x9, [x17]
 744:	f83c0057 	ldadd	x28, x23, [x2]
 748:	f8361062 	ldclr	x22, x2, [x3]
 74c:	f82b23d9 	ldeor	x11, x25, [x30]
 750:	f836309c 	ldset	x22, x28, [x4]
 754:	f826530b 	ldsmin	x6, x11, [x24]
 758:	f82c43ff 	stsmax	x12, [sp]
 75c:	f837713e 	ldumin	x23, x30, [x9]
 760:	f8266281 	ldumax	x6, x1, [x20]
 764:	f8b182c2 	swpa	x17, x2, [x22]
 768:	f8ae015b 	ldadda	x14, x27, [x10]
 76c:	f8a6127e 	ldclra	x6, x30, [x19]
 770:	f8a02179 	ldeora	x0, x25, [x11]
 774:	f8b733c0 	ldseta	x23, x0, [x30]
 778:	f8b55143 	ldsmina	x21, x3, [x10]
 77c:	f8af4016 	ldsmaxa	x15, x22, [x0]
 780:	f8b17280 	ldumina	x17, x0, [x20]
 784:	f8b0602d 	ldumaxa	x16, x13, [x1]
 788:	f8fb82ef 	swpal	x27, x15, [x23]
 78c:	f8f3003e 	ldaddal	x19, x30, [x1]
 790:	f8ef12fc 	ldclral	x15, x28, [x23]
 794:	f8e7226f 	ldeoral	x7, x15, [x19]
 798:	f8eb314c 	ldsetal	x11, x12, [x10]
 79c:	f8e65187 	ldsminal	x6, x7, [x12]
 7a0:	f8fc41a5 	ldsmaxal	x28, x5, [x13]
 7a4:	f8e97234 	lduminal	x9, x20, [x17]
 7a8:	f8f56179 	ldumaxal	x21, x25, [x11]
 7ac:	f8738318 	swpl	x19, x24, [x24]
 7b0:	f86803da 	ldaddl	x8, x26, [x30]
 7b4:	f8711112 	ldclrl	x17, x18, [x8]
 7b8:	f8622063 	ldeorl	x2, x3, [x3]
 7bc:	f87a3207 	ldsetl	x26, x7, [x16]
 7c0:	f87b50a6 	ldsminl	x27, x6, [x5]
 7c4:	f8764280 	ldsmaxl	x22, x0, [x20]
 7c8:	f86b705a 	lduminl	x11, x26, [x2]
 7cc:	f87e609d 	ldumaxl	x30, x29, [x4]
 7d0:	b82480e5 	swp	w4, w5, [x7]
 7d4:	b82a005a 	ldadd	w10, w26, [x2]
 7d8:	b83b1370 	ldclr	w27, w16, [x27]
 7dc:	b83f2157 	ldeor	wzr, w23, [x10]
 7e0:	b82431a2 	ldset	w4, w2, [x13]
 7e4:	b823506f 	ldsmin	w3, w15, [x3]
 7e8:	b82340ca 	ldsmax	w3, w10, [x6]
 7ec:	b828714b 	ldumin	w8, w11, [x10]
 7f0:	b83d61be 	ldumax	w29, w30, [x13]
 7f4:	b8ab8291 	swpa	w11, w17, [x20]
 7f8:	b8ba00d0 	ldadda	w26, w16, [x6]
 7fc:	b8b5102a 	ldclra	w21, w10, [x1]
 800:	b8bd22ec 	ldeora	w29, w12, [x23]
 804:	b8bd3108 	ldseta	w29, w8, [x8]
 808:	b8ab51ca 	ldsmina	w11, w10, [x14]
 80c:	b8a442cd 	ldsmaxa	w4, w13, [x22]
 810:	b8a770ed 	ldumina	w7, w13, [x7]
 814:	b8ae63e0 	ldumaxa	w14, w0, [sp]
 818:	b8f18382 	swpal	w17, w2, [x28]
 81c:	b8f3014b 	ldaddal	w19, w11, [x10]
 820:	b8ec1293 	ldclral	w12, w19, [x20]
 824:	b8e02108 	ldeoral	w0, w8, [x8]
 828:	b8f13303 	ldsetal	w17, w3, [x24]
 82c:	b8f950e5 	ldsminal	w25, w5, [x7]
 830:	b8f0413e 	ldsmaxal	w16, w30, [x9]
 834:	b8ea71df 	lduminal	w10, wzr, [x14]
 838:	b8f16173 	ldumaxal	w17, w19, [x11]
 83c:	b87481a1 	swpl	w20, w1, [x13]
 840:	b87a028b 	ldaddl	w26, w11, [x20]
 844:	b87213d8 	ldclrl	w18, w24, [x30]
 848:	b86c2299 	ldeorl	w12, w25, [x20]
 84c:	b86e30bd 	ldsetl	w14, w29, [x5]
 850:	b862537a 	ldsminl	w2, w26, [x27]
 854:	b879417b 	ldsmaxl	w25, w27, [x11]
 858:	b86470fd 	lduminl	w4, w29, [x7]
 85c:	b870615d 	ldumaxl	w16, w29, [x10]
 */

  static const unsigned int insns[] =
  {
    0x8b4db437,     0xcb8ce3c8,     0xab0edafb,     0xeb5499f5,
    0x0b040e39,     0x4b89503d,     0x2b89274a,     0x6b870fd5,
    0x8a4b1109,     0xaa810643,     0xca026e8a,     0xea8b7d2c,
    0x0a9e6934,     0x2a9a4555,     0x4a871d00,     0x6a084973,
    0x8a23d497,     0xaa3360c9,     0xca7ad8cc,     0xea2c3a76,
    0x0a362dbd,     0x2ab417d1,     0x4a2b23a1,     0x6a667684,
    0x1107e0de,     0x310ebd13,     0x5105b55d,     0x71047104,
    0x910ef9c3,     0xb1029e96,     0xd10b55fb,     0xf10ecf98,
    0x12099f39,     0x321b3f4d,     0x520309b5,     0x72134062,
    0x92004548,     0xb24d861b,     0xd219587b,     0xf25eaee4,
    0x14000000,     0x17ffffd7,     0x140001ee,     0x94000000,
    0x97ffffd4,     0x940001eb,     0x34000003,     0x34fffa23,
    0x34003d03,     0x35000002,     0x35fff9c2,     0x35003ca2,
    0xb4000019,     0xb4fff979,     0xb4003c59,     0xb5000012,
    0xb5fff912,     0xb5003bf2,     0x10000008,     0x10fff8a8,
    0x10003b88,     0x9000000f,     0x36700012,     0x3677f832,
    0x36703b12,     0x37780019,     0x377ff7d9,     0x37783ab9,
    0x12a203d2,     0x5286b21e,     0x72a66d35,     0x92eded92,
    0xd2eefecd,     0xf2ef69a3,     0x93400c2a,     0x330562cc,
    0x530b2071,     0x934b3860,     0xb3473cdc,     0xd3416549,
    0x13995f75,     0x93d6462e,     0x54000000,     0x54fff5a0,
    0x54003880,     0x54000001,     0x54fff541,     0x54003821,
    0x54000002,     0x54fff4e2,     0x540037c2,     0x54000002,
    0x54fff482,     0x54003762,     0x54000003,     0x54fff423,
    0x54003703,     0x54000003,     0x54fff3c3,     0x540036a3,
    0x54000004,     0x54fff364,     0x54003644,     0x54000005,
    0x54fff305,     0x540035e5,     0x54000006,     0x54fff2a6,
    0x54003586,     0x54000007,     0x54fff247,     0x54003527,
    0x54000008,     0x54fff1e8,     0x540034c8,     0x54000009,
    0x54fff189,     0x54003469,     0x5400000a,     0x54fff12a,
    0x5400340a,     0x5400000b,     0x54fff0cb,     0x540033ab,
    0x5400000c,     0x54fff06c,     0x5400334c,     0x5400000d,
    0x54fff00d,     0x540032ed,     0x5400000e,     0x54ffefae,
    0x5400328e,     0x5400000f,     0x54ffef4f,     0x5400322f,
    0xd40f9ca1,     0xd4008b22,     0xd40be1c3,     0xd423d0e0,
    0xd44dee20,     0xd503201f,     0xd69f03e0,     0xd6bf03e0,
    0xd5033fdf,     0xd503359f,     0xd50337bf,     0xd61f0380,
    0xd63f0220,     0xc8127f47,     0xc819fccc,     0xc85f7e00,
    0xc85ffc66,     0xc89ffc2e,     0xc8dfff1d,     0x881c7eef,
    0x8809fc67,     0x885f7e81,     0x885ffdf4,     0x889ffd35,
    0x88dffe25,     0x480d7fd4,     0x480afe4c,     0x485f7e64,
    0x485ffd56,     0x489ffdfe,     0x48dfff04,     0x080a7d94,
    0x0814fd7d,     0x085f7cb5,     0x085ffd24,     0x089fff9e,
    0x08dfff13,     0xc87f424b,     0xc87f9de8,     0xc83c4154,
    0xc827d469,     0x887f1a79,     0x887fa45e,     0x88305180,
    0x88259f82,     0xf81b5270,     0xb801e381,     0x381e61bc,
    0x781cd0c8,     0xf851d380,     0xb85e615c,     0x39403164,
    0x78405221,     0x3980312b,     0x789ef108,     0x78ddd1b4,
    0xb8831137,     0xfc41d089,     0xbd402a6b,     0xfc1d5299,
    0xbc1b0039,     0xf8019c14,     0xb81cfd8c,     0x381f6e7c,
    0x781c1f8d,     0xf85d2eeb,     0xb8411f1b,     0x385f4f4e,
    0x785d3ed8,     0x389f5d39,     0x7881dcc5,     0x78dffee7,
    0xb89c3dba,     0xfc50bf18,     0xbc5c9f34,     0xfc135c49,
    0xbc1c5c2e,     0xf806d433,     0xb81ca4a4,     0x3800947d,
    0x781ce420,     0xf85d04c2,     0xb858d4cf,     0x385e5444,
    0x785eb751,     0x389f3715,     0x789d04d6,     0x78dd04cb,
    0xb89fb7ce,     0xfc5975e2,     0xbc5a5679,     0xfc1416ed,
    0xbc0006b6,     0xf832c996,     0xb82c4b7e,     0x38367887,
    0x783dfaf3,     0xf87bf891,     0xb871c9a1,     0x387dfb70,
    0x78645939,     0x38b67984,     0x78a55839,     0x78fc6a09,
    0xb8aee8e8,     0xfc705b84,     0xbc7bd850,     0xfc396817,
    0xbc277a06,     0xf91ddd82,     0xb91b10a8,     0x391f8221,
    0x79197728,     0xf95ca07c,     0xb95b5d75,     0x395dc8af,
    0x795caa60,     0x399dd53d,     0x799c7397,     0x79dcb15b,
    0xb99e3b75,     0xfd5c7f7a,     0xbd5d2882,     0xfd1fb2a1,
    0xbd1d82c4,     0x58000001,     0x1800001b,     0xf882d080,
    0xd8000000,     0xf8a0cbc0,     0xf99fab00,     0x1a1803a0,
    0x3a120396,     0x5a1e0217,     0x7a0e03a7,     0x9a0e0196,
    0xba17031d,     0xda160391,     0xfa130298,     0x0b26cadb,
    0x2b38516d,     0xcb242d10,     0x6b34ea55,     0x8b3d0a2e,
    0xab2eb231,     0xcb3ac476,     0xeb3531ad,     0x3a5a722f,
    0x7a463325,     0xba5e9021,     0xfa47a222,     0x3a590a26,
    0x7a450845,     0xba514a6a,     0xfa48c9c3,     0x1a8e9109,
    0x1a85d57b,     0x5a9632eb,     0x5a9b2793,     0x9a815130,
    0x9a8c05dc,     0xda8e5096,     0xda9b257a,     0x5ac00178,
    0x5ac005ca,     0x5ac008a9,     0x5ac01292,     0x5ac01519,
    0xdac00316,     0xdac0077c,     0xdac00ba8,     0xdac00d51,
    0xdac01177,     0xdac015da,     0x1adc0895,     0x1ad60d5e,
    0x1ada205d,     0x1aca26dc,     0x1acc2b0b,     0x1ad02fd5,
    0x9acd0801,     0x9ac60e22,     0x9ad5230a,     0x9ac62525,
    0x9ac42b60,     0x9ac22c9c,     0x9bc77fc1,     0x9b4a7cbe,
    0x1b0d45e7,     0x1b0cf039,     0x9b1e2562,     0x9b03dae5,
    0x9b291159,     0x9b27c905,     0x9bba64b8,     0x9bbaf02e,
    0x1e280ad8,     0x1e261870,     0x1e392ab0,     0x1e3b3b40,
    0x1e310878,     0x1e660909,     0x1e7e1a76,     0x1e632a2e,
    0x1e743b78,     0x1e76082c,     0x1f0b7510,     0x1f128676,
    0x1f38270f,     0x1f2d5e7b,     0x1f503003,     0x1f52a873,
    0x1f6b5041,     0x1f79392c,     0x1e2042e0,     0x1e20c0d7,
    0x1e214084,     0x1e21c385,     0x1e22c1f5,     0x1e6040ab,
    0x1e60c092,     0x1e61418b,     0x1e61c10f,     0x1e624048,
    0x1e380253,     0x9e380011,     0x1e7801a0,     0x9e780136,
    0x1e2203a6,     0x9e2201cc,     0x1e6202d0,     0x9e6200ae,
    0x1e260007,     0x9e6600dc,     0x1e270342,     0x9e670004,
    0x1e2b2020,     0x1e7520c0,     0x1e202208,     0x1e6022c8,
    0x290c0045,     0x2978766e,     0x696c0c6f,     0xa9323767,
    0xa9483831,     0x29905895,     0x29f43451,     0x69ee66f5,
    0xa9bf41e4,     0xa9f6573d,     0x288a4758,     0x28e27bc3,
    0x68fc4fc3,     0xa8b70779,     0xa8fc539a,     0x283a653d,
    0x28703a79,     0xa8025879,     0xa8734ba9,     0x0c407275,
    0x4cdfa29b,     0x0cc66ec5,     0x4cdf2596,     0x0d40c131,
    0x4ddfcaa5,     0x0dd2cf8a,     0x4c408dfa,     0x0cdf8750,
    0x4d60c04e,     0x0dffcb92,     0x4df6cc13,     0x4cd24850,
    0x0c404818,     0x4d40e604,     0x4ddfe825,     0x0dd0ed47,
    0x4cdf0696,     0x0cd9008f,     0x0d60e0a0,     0x0dffe420,
    0x0deeeb9e,     0xba5fd3e3,     0x3a5f03e5,     0xfa411be4,
    0x7a42cbe2,     0x93df03ff,     0xc820ffff,     0x8822fc7f,
    0xc8247cbf,     0x88267fff,     0x4e010fe0,     0x4e081fe1,
    0x4e0c1fe1,     0x4e0a1fe1,     0x4e071fe1,     0x4cc0ac3f,
    0x1e601000,     0x1e603000,     0x1e621000,     0x1e623000,
    0x1e641000,     0x1e643000,     0x1e661000,     0x1e663000,
    0x1e681000,     0x1e683000,     0x1e6a1000,     0x1e6a3000,
    0x1e6c1000,     0x1e6c3000,     0x1e6e1000,     0x1e6e3000,
    0x1e701000,     0x1e703000,     0x1e721000,     0x1e723000,
    0x1e741000,     0x1e743000,     0x1e761000,     0x1e763000,
    0x1e781000,     0x1e783000,     0x1e7a1000,     0x1e7a3000,
    0x1e7c1000,     0x1e7c3000,     0x1e7e1000,     0x1e7e3000,
    0xf83a8229,     0xf83c0057,     0xf8361062,     0xf82b23d9,
    0xf836309c,     0xf826530b,     0xf82c43ff,     0xf837713e,
    0xf8266281,     0xf8b182c2,     0xf8ae015b,     0xf8a6127e,
    0xf8a02179,     0xf8b733c0,     0xf8b55143,     0xf8af4016,
    0xf8b17280,     0xf8b0602d,     0xf8fb82ef,     0xf8f3003e,
    0xf8ef12fc,     0xf8e7226f,     0xf8eb314c,     0xf8e65187,
    0xf8fc41a5,     0xf8e97234,     0xf8f56179,     0xf8738318,
    0xf86803da,     0xf8711112,     0xf8622063,     0xf87a3207,
    0xf87b50a6,     0xf8764280,     0xf86b705a,     0xf87e609d,
    0xb82480e5,     0xb82a005a,     0xb83b1370,     0xb83f2157,
    0xb82431a2,     0xb823506f,     0xb82340ca,     0xb828714b,
    0xb83d61be,     0xb8ab8291,     0xb8ba00d0,     0xb8b5102a,
    0xb8bd22ec,     0xb8bd3108,     0xb8ab51ca,     0xb8a442cd,
    0xb8a770ed,     0xb8ae63e0,     0xb8f18382,     0xb8f3014b,
    0xb8ec1293,     0xb8e02108,     0xb8f13303,     0xb8f950e5,
    0xb8f0413e,     0xb8ea71df,     0xb8f16173,     0xb87481a1,
    0xb87a028b,     0xb87213d8,     0xb86c2299,     0xb86e30bd,
    0xb862537a,     0xb879417b,     0xb86470fd,     0xb870615d,

  };
// END  Generated code -- do not edit

  asm_check((unsigned int *)entry, insns, sizeof insns / sizeof insns[0]);

  {
    address PC = __ pc();
    __ ld1(v0, __ T16B, Address(r16));      // No offset
    __ ld1(v0, __ T8H, __ post(r16, 16));   // Post-index
    __ ld2(v0, v1, __ T8H, __ post(r24, 16 * 2));   // Post-index
    __ ld1(v0, __ T16B, __ post(r16, r17)); // Register post-index
    static const unsigned int vector_insns[] = {
       0x4c407200, // ld1   {v0.16b}, [x16]
       0x4cdf7600, // ld1   {v0.8h}, [x16], #16
       0x4cdf8700, // ld2   {v0.8h, v1.8h}, [x24], #32
       0x4cd17200, // ld1   {v0.16b}, [x16], x17
      };
    asm_check((unsigned int *)PC, vector_insns,
              sizeof vector_insns / sizeof vector_insns[0]);
  }
}
#endif // ASSERT

#undef __

void Assembler::emit_data64(jlong data,
                            relocInfo::relocType rtype,
                            int format) {
  if (rtype == relocInfo::none) {
    emit_int64(data);
  } else {
    emit_data64(data, Relocation::spec_simple(rtype), format);
  }
}

void Assembler::emit_data64(jlong data,
                            RelocationHolder const& rspec,
                            int format) {

  assert(inst_mark() != NULL, "must be inside InstructionMark");
  // Do not use AbstractAssembler::relocate, which is not intended for
  // embedded words.  Instead, relocate to the enclosing instruction.
  code_section()->relocate(inst_mark(), rspec, format);
  emit_int64(data);
}

extern "C" {
  void das(uint64_t start, int len) {
    ResourceMark rm;
    len <<= 2;
    if (len < 0)
      Disassembler::decode((address)start + len, (address)start);
    else
      Disassembler::decode((address)start, (address)start + len);
  }

  JNIEXPORT void das1(uintptr_t insn) {
    das(insn, 1);
  }
}

#define gas_assert(ARG1) assert(ARG1, #ARG1)

#define __ as->

void Address::lea(MacroAssembler *as, Register r) const {
  Relocation* reloc = _rspec.reloc();
  relocInfo::relocType rtype = (relocInfo::relocType) reloc->type();

  switch(_mode) {
  case base_plus_offset: {
    if (_offset == 0 && _base == r) // it's a nop
      break;
    if (_offset > 0)
      __ add(r, _base, _offset);
    else
      __ sub(r, _base, -_offset);
      break;
  }
  case base_plus_offset_reg: {
    __ add(r, _base, _index, _ext.op(), MAX2(_ext.shift(), 0));
    break;
  }
  case literal: {
    if (rtype == relocInfo::none)
      __ mov(r, target());
    else
      __ movptr(r, (uint64_t)target());
    break;
  }
  default:
    ShouldNotReachHere();
  }
}

void Assembler::adrp(Register reg1, const Address &dest, uintptr_t &byte_offset) {
  ShouldNotReachHere();
}

#undef __

#define starti Instruction_aarch64 do_not_use(this); set_current(&do_not_use)

  void Assembler::adr(Register Rd, address adr) {
    intptr_t offset = adr - pc();
    int offset_lo = offset & 3;
    offset >>= 2;
    starti;
    f(0, 31), f(offset_lo, 30, 29), f(0b10000, 28, 24), sf(offset, 23, 5);
    rf(Rd, 0);
  }

  void Assembler::_adrp(Register Rd, address adr) {
    uint64_t pc_page = (uint64_t)pc() >> 12;
    uint64_t adr_page = (uint64_t)adr >> 12;
    intptr_t offset = adr_page - pc_page;
    int offset_lo = offset & 3;
    offset >>= 2;
    starti;
    f(1, 31), f(offset_lo, 30, 29), f(0b10000, 28, 24), sf(offset, 23, 5);
    rf(Rd, 0);
  }

#undef starti

Address::Address(address target, relocInfo::relocType rtype) : _mode(literal){
  _is_lval = false;
  _target = target;
  switch (rtype) {
  case relocInfo::oop_type:
  case relocInfo::metadata_type:
    // Oops are a special case. Normally they would be their own section
    // but in cases like icBuffer they are literals in the code stream that
    // we don't have a section for. We use none so that we get a literal address
    // which is always patchable.
    break;
  case relocInfo::external_word_type:
    _rspec = external_word_Relocation::spec(target);
    break;
  case relocInfo::internal_word_type:
    _rspec = internal_word_Relocation::spec(target);
    break;
  case relocInfo::opt_virtual_call_type:
    _rspec = opt_virtual_call_Relocation::spec();
    break;
  case relocInfo::static_call_type:
    _rspec = static_call_Relocation::spec();
    break;
  case relocInfo::runtime_call_type:
    _rspec = runtime_call_Relocation::spec();
    break;
  case relocInfo::poll_type:
  case relocInfo::poll_return_type:
    _rspec = Relocation::spec_simple(rtype);
    break;
  case relocInfo::none:
    _rspec = RelocationHolder::none;
    break;
  default:
    ShouldNotReachHere();
    break;
  }
}

void Assembler::b(const Address &dest) {
  code_section()->relocate(pc(), dest.rspec());
  b(dest.target());
}

void Assembler::bl(const Address &dest) {
  code_section()->relocate(pc(), dest.rspec());
  bl(dest.target());
}

void Assembler::adr(Register r, const Address &dest) {
  code_section()->relocate(pc(), dest.rspec());
  adr(r, dest.target());
}

void Assembler::br(Condition cc, Label &L) {
  if (L.is_bound()) {
    br(cc, target(L));
  } else {
    L.add_patch_at(code(), locator());
    br(cc, pc());
  }
}

void Assembler::wrap_label(Label &L,
                                 Assembler::uncond_branch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(target(L));
  } else {
    L.add_patch_at(code(), locator());
    (this->*insn)(pc());
  }
}

void Assembler::wrap_label(Register r, Label &L,
                                 compare_and_branch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(r, target(L));
  } else {
    L.add_patch_at(code(), locator());
    (this->*insn)(r, pc());
  }
}

void Assembler::wrap_label(Register r, int bitpos, Label &L,
                                 test_and_branch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(r, bitpos, target(L));
  } else {
    L.add_patch_at(code(), locator());
    (this->*insn)(r, bitpos, pc());
  }
}

void Assembler::wrap_label(Label &L, prfop op, prefetch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(target(L), op);
  } else {
    L.add_patch_at(code(), locator());
    (this->*insn)(pc(), op);
  }
}

// An "all-purpose" add/subtract immediate, per ARM documentation:
// A "programmer-friendly" assembler may accept a negative immediate
// between -(2^24 -1) and -1 inclusive, causing it to convert a
// requested ADD operation to a SUB, or vice versa, and then encode
// the absolute value of the immediate as for uimm24.
void Assembler::add_sub_immediate(Register Rd, Register Rn, unsigned uimm, int op,
                                  int negated_op) {
  bool sets_flags = op & 1;   // this op sets flags
  union {
    unsigned u;
    int imm;
  };
  u = uimm;
  bool shift = false;
  bool neg = imm < 0;
  if (neg) {
    imm = -imm;
    op = negated_op;
  }
  assert(Rd != sp || imm % 16 == 0, "misaligned stack");
  if (imm >= (1 << 11)
      && ((imm >> 12) << 12 == imm)) {
    imm >>= 12;
    shift = true;
  }
  f(op, 31, 29), f(0b10001, 28, 24), f(shift, 23, 22), f(imm, 21, 10);

  // add/subtract immediate ops with the S bit set treat r31 as zr;
  // with S unset they use sp.
  if (sets_flags)
    zrf(Rd, 0);
  else
    srf(Rd, 0);

  srf(Rn, 5);
}

bool Assembler::operand_valid_for_add_sub_immediate(int64_t imm) {
  uint64_t uimm = (uint64_t)uabs(imm);
  if (uimm < (1 << 12))
    return true;
  if (uimm < (1 << 24)
      && ((uimm >> 12) << 12 == uimm)) {
    return true;
  }
  return false;
}

bool Assembler::operand_valid_for_logical_immediate(bool is32, uint64_t imm) {
  return encode_logical_immediate(is32, imm) != 0xffffffff;
}

static uint64_t doubleTo64Bits(jdouble d) {
  union {
    jdouble double_value;
    uint64_t double_bits;
  };

  double_value = d;
  return double_bits;
}

bool Assembler::operand_valid_for_float_immediate(double imm) {
  // If imm is all zero bits we can use ZR as the source of a
  // floating-point value.
  if (doubleTo64Bits(imm) == 0)
    return true;

  // Otherwise try to encode imm then convert the encoded value back
  // and make sure it's the exact same bit pattern.
  unsigned result = encoding_for_fp_immediate(imm);
  return doubleTo64Bits(imm) == fp_immediate_for_encoding(result, true);
}

int AbstractAssembler::code_fill_byte() {
  return 0;
}

// n.b. this is implemented in subclass MacroAssembler
void Assembler::bang_stack_with_offset(int offset) { Unimplemented(); }


// and now the routines called by the assembler which encapsulate the
// above encode and decode functions

uint32_t
asm_util::encode_logical_immediate(bool is32, uint64_t imm)
{
  if (is32) {
    /* Allow all zeros or all ones in top 32-bits, so that
       constant expressions like ~1 are permitted. */
    if (imm >> 32 != 0 && imm >> 32 != 0xffffffff)
      return 0xffffffff;
    /* Replicate the 32 lower bits to the 32 upper bits.  */
    imm &= 0xffffffff;
    imm |= imm << 32;
  }

  return encoding_for_logical_immediate(imm);
}

unsigned Assembler::pack(double value) {
  float val = (float)value;
  unsigned result = encoding_for_fp_immediate(val);
  guarantee(unpack(result) == value,
            "Invalid floating-point immediate operand");
  return result;
}

// Packed operands for  Floating-point Move (immediate)

static float unpack(unsigned value) {
  union {
    unsigned ival;
    float val;
  };
  ival = fp_immediate_for_encoding(value, 0);
  return val;
}
